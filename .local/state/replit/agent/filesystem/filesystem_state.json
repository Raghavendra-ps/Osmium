{"file_contents":{"hooks.py":{"content":"from . import __version__ as app_version\n\napp_name = \"ai_assistant\"\napp_title = \"AI Assistant\"\napp_publisher = \"ERPNext\"\napp_description = \"AI Assistant for ERPNext with intelligent chat and database interactions\"\napp_email = \"support@erpnext.com\"\napp_license = \"MIT\"\n\n# Includes in <head>\n# ------------------\n\n# include js, css files in header of desk.html\n# app_include_css = \"/assets/ai_assistant/css/ai_assistant.css\"\n# app_include_js = \"/assets/ai_assistant/js/ai_assistant.js\"\n\n# include js, css files in header of web template\n# web_include_css = \"/assets/ai_assistant/css/ai_assistant.css\"\n# web_include_js = \"/assets/ai_assistant/js/ai_assistant.js\"\n\n# include custom scss in every website theme (without file extension \".scss\")\n# website_theme_scss = \"ai_assistant/public/scss/website\"\n\n# include js, css files in header of web form\n# webform_include_js = {\"doctype\": \"public/js/doctype.js\"}\n# webform_include_css = {\"doctype\": \"public/css/doctype.css\"}\n\n# include js in page\n# page_js = {\"page\" : \"public/js/file.js\"}\n\n# include js in doctype views\n# doctype_js = {\"doctype\" : \"public/js/doctype.js\"}\n# doctype_list_js = {\"doctype\" : \"public/js/doctype_list.js\"}\n# doctype_tree_js = {\"doctype\" : \"public/js/doctype_tree.js\"}\n# doctype_calendar_js = {\"doctype\" : \"public/js/doctype_calendar.js\"}\n\n# Home Pages\n# ----------\n\n# application home page (will override Website Settings)\n# home_page = \"login\"\n\n# website user home page (by Role)\n# role_home_page = {\n#\t\"Role\": \"home_page\"\n# }\n\n# Generators\n# ----------\n\n# automatically create page for each record of this doctype\n# website_generators = [\"Web Page\"]\n\n# Installation\n# ------------\n\n# before_install = \"ai_assistant.install.before_install\"\n# after_install = \"ai_assistant.install.after_install\"\n\n# Desk Notifications\n# ------------------\n# See frappe.core.notifications.get_notification_config\n\n# notification_config = \"ai_assistant.notifications.get_notification_config\"\n\n# Permissions\n# -----------\n# Permissions evaluated in scripted ways\n\n# permission_query_conditions = {\n#\t\"Event\": \"frappe.desk.doctype.event.event.get_permission_query_conditions\",\n# }\n#\n# has_permission = {\n#\t\"Event\": \"frappe.desk.doctype.event.event.has_permission\",\n# }\n\n# DocType Class\n# ---------------\n# Override standard doctype classes\n\n# override_doctype_class = {\n#\t\"ToDo\": \"custom_app.overrides.CustomToDo\"\n# }\n\n# Document Events\n# ---------------\n# Hook on document methods and events\n\n# doc_events = {\n#\t\"*\": {\n#\t\t\"on_update\": \"method\",\n#\t\t\"on_cancel\": \"method\",\n#\t\t\"on_trash\": \"method\"\n#\t}\n# }\n\n# Scheduled Tasks\n# ---------------\n\n# scheduler_events = {\n#\t\"all\": [\n#\t\t\"ai_assistant.tasks.all\"\n#\t],\n#\t\"daily\": [\n#\t\t\"ai_assistant.tasks.daily\"\n#\t],\n#\t\"hourly\": [\n#\t\t\"ai_assistant.tasks.hourly\"\n#\t],\n#\t\"weekly\": [\n#\t\t\"ai_assistant.tasks.weekly\"\n#\t]\n#\t\"monthly\": [\n#\t\t\"ai_assistant.tasks.monthly\"\n#\t]\n# }\n\n# Testing\n# -------\n\n# before_tests = \"ai_assistant.install.before_tests\"\n\n# Overriding Methods\n# ------------------------------\n#\n# override_whitelisted_methods = {\n#\t\"frappe.desk.doctype.event.event.get_events\": \"ai_assistant.event.get_events\"\n# }\n#\n# each overriding function accepts a `data` argument;\n# generated from the base implementation of the doctype dashboard,\n# along with any modifications made in other Frappe apps\n# override_doctype_dashboards = {\n#\t\"Task\": \"ai_assistant.task.get_dashboard_data\"\n# }\n\n# exempt linked doctypes from being automatically cancelled\n#\n# auto_cancel_exempted_doctypes = [\"Auto Repeat\"]\n\n\n# User Data Protection\n# --------------------\n\n# user_data_fields = [\n#\t{\n#\t\t\"doctype\": \"{doctype_1}\",\n#\t\t\"filter_by\": \"{filter_by}\",\n#\t\t\"redact_fields\": [\"{field_1}\", \"{field_2}\"],\n#\t\t\"partial\": 1,\n#\t},\n#\t{\n#\t\t\"doctype\": \"{doctype_2}\",\n#\t\t\"filter_by\": \"{filter_by}\",\n#\t\t\"partial\": 1,\n#\t},\n#\t{\n#\t\t\"doctype\": \"{doctype_3}\",\n#\t\t\"strict\": False,\n#\t},\n#\t{\n#\t\t\"doctype\": \"{doctype_4}\"\n#\t}\n# ]\n\n# Authentication and authorization\n# --------------------------------\n\n# auth_hooks = [\n#\t\"ai_assistant.auth.validate\"\n# ]\n\n# Translation\n# --------------------------------\n\n# Make link fields search translated document names for these DocTypes\n# Recommended only for DocTypes which have limited documents with untranslated names\n# For example: Role, Gender, etc.\n# translated_search_doctypes = []","size_bytes":4278},"replit.md":{"content":"# Overview\n\nThis is an ERPNext AI Assistant application that provides a natural language interface for interacting with ERPNext databases. The system combines a React-based frontend with an Express backend, integrated with Ollama for AI-powered chat functionality and database operations. Users can ask questions in natural language and receive intelligent responses, with the AI analyzing and executing appropriate ERPNext commands while maintaining safety guardrails.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: React with TypeScript using Vite as the build tool\n- **UI Library**: Shadcn/ui components built on Radix UI primitives with Tailwind CSS styling\n- **State Management**: TanStack Query for server state management and React hooks for local state\n- **Routing**: Wouter for client-side routing\n- **Real-time Communication**: WebSocket connection for live chat functionality\n\n## Backend Architecture\n- **Framework**: Express.js with TypeScript, running on Node.js\n- **API Design**: RESTful endpoints with WebSocket support for real-time chat\n- **Data Layer**: Drizzle ORM with PostgreSQL database support\n- **Command Execution**: ERPNext service for executing bench commands safely\n- **AI Integration**: Ollama service for natural language processing and command generation\n\n## Database Design\n- **Primary Database**: PostgreSQL with Drizzle ORM for application data\n- **Schema Management**: Automated migrations with drizzle-kit\n- **Core Tables**: Users, chat messages, database schema cache, and application settings\n- **ERPNext Integration**: Direct command execution against ERPNext instances via bench CLI\n\n## AI and NLP Architecture\n- **AI Provider**: Ollama for local LLM inference\n- **Command Analysis**: Multi-step process including safety validation, command generation, and execution confirmation\n- **Context Management**: Database schema scanning and caching for informed AI responses\n- **Safety Features**: Destructive operation detection, confirmation workflows, and safe mode enforcement\n\n## Real-time Communication\n- **WebSocket Server**: Integrated with Express HTTP server for bidirectional communication\n- **Message Types**: Chat messages, command confirmations, database scans, and settings updates\n- **Connection Management**: Client connection tracking with automatic reconnection support\n\n## Security and Safety\n- **Command Validation**: Input sanitization and command structure validation before execution\n- **Safe Mode**: Configurable safety restrictions for destructive operations\n- **Confirmation Flows**: User approval required for potentially dangerous database operations\n- **Timeout Protection**: Command execution timeouts to prevent hanging operations\n\n# External Dependencies\n\n## Core Infrastructure\n- **Database**: PostgreSQL via Neon serverless database (@neondatabase/serverless)\n- **ORM**: Drizzle ORM for database operations and schema management\n- **Build Tools**: Vite for frontend bundling, esbuild for backend compilation\n\n## AI and Machine Learning\n- **Ollama**: Local LLM server for natural language processing and command generation\n- **Models**: Configurable model support (default: llama2) for different AI capabilities\n\n## UI and Styling\n- **Radix UI**: Comprehensive set of unstyled, accessible UI components\n- **Tailwind CSS**: Utility-first CSS framework for responsive design\n- **Lucide React**: Icon library for consistent visual elements\n\n## Development and Deployment\n- **TypeScript**: Full-stack type safety and improved developer experience\n- **ESLint/Prettier**: Code quality and formatting tools\n- **Replit Integration**: Development environment plugins and optimizations\n\n## ERPNext Integration\n- **Bench CLI**: Direct integration with ERPNext's command-line interface\n- **Frappe Framework**: Underlying framework commands for database operations and system management\n- **Site Management**: Multi-site support with configurable site targeting","size_bytes":4014},"setup.py":{"content":"from setuptools import setup, find_packages\n\nwith open(\"requirements.txt\") as f:\n\tinstall_requires = f.read().strip().split(\"\\n\")\n\n# get version from __version__ variable in ai_assistant/__init__.py\nfrom ai_assistant import __version__ as version\n\nsetup(\n\tname=\"ai_assistant\",\n\tversion=version,\n\tdescription=\"AI Assistant for ERPNext with intelligent chat and database interactions\",\n\tauthor=\"ERPNext\",\n\tauthor_email=\"support@erpnext.com\",\n\tpackages=find_packages(),\n\tzip_safe=False,\n\tinclude_package_data=True,\n\tinstall_requires=install_requires\n)","size_bytes":548},"ai_assistant/__init__.py":{"content":"__version__ = '0.0.1'\n","size_bytes":22},"ai_assistant/ai_assistant/__init__.py":{"content":"","size_bytes":0},"ai_assistant/ai_assistant/api.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport frappe\nfrom frappe import _\nfrom frappe.utils import now_datetime, cint\nfrom ai_assistant.ai_assistant.services.ollama import AIService, get_ollama_service\nfrom ai_assistant.ai_assistant.services.erpnext_exec import ERPNextExecutor\nfrom ai_assistant.ai_assistant.services.schema import SchemaService\n\n\n@frappe.whitelist()\ndef send_message(session_id, message, role=\"user\"):\n    \"\"\"\n    Send a chat message and get AI response.\n    \n    Args:\n        session_id (str): Chat session ID\n        message (str): Message content\n        role (str): Message role ('user' or 'assistant')\n    \n    Returns:\n        dict: Response with message ID and AI response\n    \"\"\"\n    try:\n        # Check permissions\n        if not frappe.has_permission(\"AI Chat Message\", \"create\"):\n            frappe.throw(_(\"Not permitted to create chat messages\"), frappe.PermissionError)\n        \n        # Validate session\n        if session_id:\n            if not frappe.db.exists(\"AI Chat Session\", session_id):\n                frappe.throw(_(\"Chat session not found\"))\n            \n            # Check if user has access to this session\n            session_user = frappe.db.get_value(\"AI Chat Session\", session_id, \"user\")\n            if session_user != frappe.session.user and not frappe.has_permission(\"AI Chat Session\", \"read\"):\n                frappe.throw(_(\"Not permitted to access this chat session\"), frappe.PermissionError)\n        else:\n            # Auto-scan database if enabled for new session\n            try:\n                settings_doc = frappe.get_single(\"AI Assistant Settings\")\n                if settings_doc.auto_scan_database:\n                    # Trigger database scan for new session context\n                    schema_data = SchemaService.scan_database(include_custom=True, max_tables=500)\n                    SchemaService.save_schema_to_settings(schema_data)\n                    \n                    frappe.logger(\"ai_assistant\").info(f\"Database scanned for new session. \"\n                                                     f\"Found {schema_data['summary']['total_doctypes']} DocTypes \"\n                                                     f\"and {schema_data['summary']['total_tables']} tables.\")\n            except Exception as scan_error:\n                frappe.log_error(f\"Database scan error during session creation: {str(scan_error)}\", \"AI Assistant\")\n                # Continue with session creation even if scan fails\n            \n            # Create new session\n            session_doc = frappe.get_doc({\n                \"doctype\": \"AI Chat Session\",\n                \"title\": f\"Chat Session - {frappe.format(now_datetime(), 'datetime')}\",\n                \"user\": frappe.session.user,\n                \"session_start\": now_datetime(),\n                \"status\": \"Active\"\n            })\n            session_doc.insert()\n            session_id = session_doc.name\n        \n        # Create user message\n        user_msg = frappe.get_doc({\n            \"doctype\": \"AI Chat Message\",\n            \"session\": session_id,\n            \"role\": \"user\",\n            \"content\": message,\n            \"user\": frappe.session.user,\n            \"timestamp\": now_datetime()\n        })\n        user_msg.insert()\n        \n        # Generate AI response if role is user\n        if role == \"user\":\n            try:\n                # Get settings\n                settings = get_settings()\n                \n                # Get schema context for AI\n                schema_context = SchemaService.get_schema_context()\n                \n                # Generate AI response using AI service\n                provider = settings.get(\"provider\", \"ollama\")\n                if provider == \"openai\":\n                    # Get API key directly from DocType (not from sanitized settings)\n                    settings_doc = frappe.get_single(\"AI Assistant Settings\")\n                    openai_api_key = settings_doc.openai_api_key\n                    \n                    if not openai_api_key:\n                        frappe.throw(_(\"OpenAI API key is not configured. Please set it in AI Assistant Settings.\"))\n                    \n                    ai_service = AIService(\n                        provider=\"openai\",\n                        model=settings.get(\"openai_model\", \"gpt-5\"),\n                        openai_api_key=openai_api_key\n                    )\n                else:\n                    ai_service = AIService(\n                        provider=\"ollama\",\n                        url=settings.get(\"ollama_url\", \"http://localhost:11434\"),\n                        model=settings.get(\"ollama_model\", \"llama2\")\n                    )\n                \n                # Analyze if this is a command\n                command_analysis = ai_service.analyze_command(message, schema_context)\n                \n                ai_response = ai_service.generate_response(message, schema_context)\n                \n                # Create assistant message\n                assistant_msg = frappe.get_doc({\n                    \"doctype\": \"AI Chat Message\",\n                    \"session\": session_id,\n                    \"role\": \"assistant\",\n                    \"content\": ai_response,\n                    \"user\": frappe.session.user,\n                    \"timestamp\": now_datetime()\n                })\n                \n                # If command analysis indicates execution needed\n                if command_analysis and command_analysis.get(\"isDestructive\"):\n                    assistant_msg.command_executed = command_analysis.get(\"command\", \"\")\n                    \n                assistant_msg.insert()\n                \n                return {\n                    \"success\": True,\n                    \"user_message_id\": user_msg.name,\n                    \"assistant_message_id\": assistant_msg.name,\n                    \"session_id\": session_id,\n                    \"ai_response\": ai_response,\n                    \"command_analysis\": command_analysis\n                }\n                \n            except Exception as ai_error:\n                frappe.log_error(f\"AI Response Error: {str(ai_error)}\", \"AI Assistant\")\n                \n                # Create error response\n                error_msg = frappe.get_doc({\n                    \"doctype\": \"AI Chat Message\",\n                    \"session\": session_id,\n                    \"role\": \"assistant\",\n                    \"content\": f\"I encountered an error processing your request: {str(ai_error)}\",\n                    \"user\": frappe.session.user,\n                    \"timestamp\": now_datetime(),\n                    \"is_error\": 1\n                })\n                error_msg.insert()\n                \n                return {\n                    \"success\": False,\n                    \"user_message_id\": user_msg.name,\n                    \"assistant_message_id\": error_msg.name,\n                    \"session_id\": session_id,\n                    \"error\": str(ai_error)\n                }\n        \n        return {\n            \"success\": True,\n            \"message_id\": user_msg.name,\n            \"session_id\": session_id\n        }\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Send Message Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to send message: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef confirm_execute(message_id, command):\n    \"\"\"\n    Confirm and execute a command from AI assistant.\n    \n    Args:\n        message_id (str): AI Chat Message ID\n        command (str): Command to execute\n    \n    Returns:\n        dict: Execution result\n    \"\"\"\n    try:\n        # Check permissions\n        if not frappe.has_permission(\"AI Chat Message\", \"write\"):\n            frappe.throw(_(\"Not permitted to execute commands\"), frappe.PermissionError)\n        \n        # Get message\n        message = frappe.get_doc(\"AI Chat Message\", message_id)\n        \n        # Verify user has access\n        if message.user != frappe.session.user and not frappe.has_permission(\"AI Chat Message\", \"read\"):\n            frappe.throw(_(\"Not permitted to access this message\"), frappe.PermissionError)\n        \n        # Get settings\n        settings = get_settings()\n        \n        # Check if safe mode is enabled and user confirmed\n        if settings.get(\"safe_mode\") and settings.get(\"confirm_destructive\"):\n            # Execute command\n            executor = ERPNextExecutor(safe_mode=settings.get(\"safe_mode\", True))\n            result = executor.execute_command(command)\n            \n            # Update message with execution results\n            message.command_executed = command\n            message.command_result = json.dumps(result, indent=2)\n            message.is_error = not result.get(\"success\", False)\n            message.execution_time = result.get(\"executionTime\", 0)\n            message.save()\n            \n            # Log if enabled\n            if settings.get(\"log_commands\"):\n                frappe.logger(\"ai_assistant\").info(f\"Command executed: {command} | Result: {result}\")\n            \n            return result\n        else:\n            frappe.throw(_(\"Command execution not allowed in current configuration\"))\n            \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Confirm Execute Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to execute command: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef clear_history(session_id=None):\n    \"\"\"\n    Clear chat history for a session or all sessions for current user.\n    \n    Args:\n        session_id (str, optional): Specific session to clear\n    \n    Returns:\n        dict: Success status\n    \"\"\"\n    try:\n        # Check permissions\n        if not frappe.has_permission(\"AI Chat Message\", \"delete\"):\n            frappe.throw(_(\"Not permitted to delete chat messages\"), frappe.PermissionError)\n        \n        if session_id:\n            # Clear specific session\n            if not frappe.db.exists(\"AI Chat Session\", session_id):\n                frappe.throw(_(\"Chat session not found\"))\n            \n            # Check access\n            session_user = frappe.db.get_value(\"AI Chat Session\", session_id, \"user\")\n            if session_user != frappe.session.user and not frappe.has_permission(\"AI Chat Session\", \"delete\"):\n                frappe.throw(_(\"Not permitted to clear this session\"), frappe.PermissionError)\n            \n            # Delete messages\n            frappe.db.delete(\"AI Chat Message\", {\"session\": session_id})\n            \n            # Update session\n            frappe.db.set_value(\"AI Chat Session\", session_id, {\n                \"message_count\": 0,\n                \"session_end\": now_datetime(),\n                \"status\": \"Completed\"\n            })\n            \n            return {\"success\": True, \"message\": _(\"Session history cleared\")}\n        else:\n            # Clear all sessions for current user\n            user_sessions = frappe.get_all(\"AI Chat Session\", \n                filters={\"user\": frappe.session.user}, \n                pluck=\"name\")\n            \n            if user_sessions:\n                frappe.db.delete(\"AI Chat Message\", {\"session\": [\"in\", user_sessions]})\n                frappe.db.set_value(\"AI Chat Session\", {\"name\": [\"in\", user_sessions]}, {\n                    \"message_count\": 0,\n                    \"session_end\": now_datetime(),\n                    \"status\": \"Completed\"\n                })\n            \n            return {\"success\": True, \"message\": _(\"All chat history cleared\")}\n            \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Clear History Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to clear history: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_settings():\n    \"\"\"\n    Get AI Assistant settings.\n    \n    Returns:\n        dict: Current settings\n    \"\"\"\n    try:\n        # Check permissions - any authenticated user can read settings\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        settings = frappe.get_single(\"AI Assistant Settings\")\n        \n        return {\n            \"provider\": settings.provider or \"ollama\",\n            \"ollama_url\": settings.ollama_url or \"http://localhost:11434\",\n            \"ollama_model\": settings.ollama_model or \"llama2\",\n            \"has_openai_key\": bool(settings.openai_api_key),  # Never return the actual key\n            \"openai_model\": settings.openai_model or \"gpt-5\",\n            \"safe_mode\": settings.safe_mode,\n            \"confirm_destructive\": settings.confirm_destructive,\n            \"log_commands\": settings.log_commands\n        }\n        \n    except Exception as e:\n        frappe.log_error(f\"Get Settings Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get settings: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef update_settings(provider=None, ollama_url=None, ollama_model=None, \n                   openai_api_key=None, openai_model=None, safe_mode=None, \n                   confirm_destructive=None, log_commands=None):\n    \"\"\"\n    Update AI Assistant settings.\n    \n    Args:\n        provider (str, optional): AI provider (ollama or openai)\n        ollama_url (str, optional): Ollama server URL\n        ollama_model (str, optional): Ollama model name\n        openai_api_key (str, optional): OpenAI API key\n        openai_model (str, optional): OpenAI model name\n        safe_mode (bool, optional): Enable safe mode\n        confirm_destructive (bool, optional): Confirm destructive operations\n        log_commands (bool, optional): Log executed commands\n    \n    Returns:\n        dict: Updated settings\n    \"\"\"\n    try:\n        # Check permissions - only System Manager can update settings\n        if not frappe.has_permission(\"AI Assistant Settings\", \"write\"):\n            frappe.throw(_(\"Not permitted to update AI Assistant settings\"), frappe.PermissionError)\n        \n        # Additional security check for System Manager role\n        if \"System Manager\" not in frappe.get_roles(frappe.session.user):\n            frappe.throw(_(\"Only System Managers can update AI Assistant settings\"), frappe.PermissionError)\n        \n        settings = frappe.get_single(\"AI Assistant Settings\")\n        \n        # Update provided fields\n        if provider is not None:\n            settings.provider = provider\n        if ollama_url is not None:\n            settings.ollama_url = ollama_url\n        if ollama_model is not None:\n            settings.ollama_model = ollama_model\n        if openai_api_key is not None:\n            settings.openai_api_key = openai_api_key\n        if openai_model is not None:\n            settings.openai_model = openai_model\n        if safe_mode is not None:\n            settings.safe_mode = cint(safe_mode)\n        if confirm_destructive is not None:\n            settings.confirm_destructive = cint(confirm_destructive)\n        if log_commands is not None:\n            settings.log_commands = cint(log_commands)\n        \n        settings.save()\n        \n        return get_settings()\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Update Settings Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to update settings: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef start_scan():\n    \"\"\"\n    Start database schema scanning in background.\n    \n    Returns:\n        dict: Scan status\n    \"\"\"\n    try:\n        # Check permissions - only System Manager can start scan\n        if not frappe.has_permission(\"AI Assistant Settings\", \"write\"):\n            frappe.throw(_(\"Not permitted to start schema scan\"), frappe.PermissionError)\n        \n        # Enqueue background job\n        frappe.enqueue(\n            \"ai_assistant.ai_assistant.services.schema.scan_database_background\",\n            queue=\"default\",\n            timeout=600,  # 10 minutes\n            job_name=\"ai_assistant_schema_scan\"\n        )\n        \n        return {\n            \"success\": True,\n            \"message\": _(\"Schema scan started in background\")\n        }\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Start Scan Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to start schema scan: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_schema():\n    \"\"\"\n    Get cached database schema.\n    \n    Returns:\n        dict: Schema information\n    \"\"\"\n    try:\n        # Check permissions - authenticated users can read schema\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        schema_context = SchemaService.get_schema_context()\n        \n        return {\n            \"success\": True,\n            \"schema\": schema_context\n        }\n        \n    except Exception as e:\n        frappe.log_error(f\"Get Schema Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get schema: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_chat_sessions():\n    \"\"\"\n    Get chat sessions for current user.\n    \n    Returns:\n        list: List of chat sessions\n    \"\"\"\n    try:\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        sessions = frappe.get_all(\"AI Chat Session\",\n            filters={\"user\": frappe.session.user},\n            fields=[\"name\", \"title\", \"status\", \"session_start\", \"session_end\", \"message_count\"],\n            order_by=\"session_start desc\",\n            limit=50\n        )\n        \n        return {\"success\": True, \"sessions\": sessions}\n        \n    except Exception as e:\n        frappe.log_error(f\"Get Chat Sessions Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get chat sessions: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_chat_messages(session_id):\n    \"\"\"\n    Get chat messages for a session.\n    \n    Args:\n        session_id (str): Chat session ID\n    \n    Returns:\n        list: List of chat messages\n    \"\"\"\n    try:\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        # Check session exists and access\n        if not frappe.db.exists(\"AI Chat Session\", session_id):\n            frappe.throw(_(\"Chat session not found\"))\n        \n        session_user = frappe.db.get_value(\"AI Chat Session\", session_id, \"user\")\n        if session_user != frappe.session.user and not frappe.has_permission(\"AI Chat Session\", \"read\"):\n            frappe.throw(_(\"Not permitted to access this chat session\"), frappe.PermissionError)\n        \n        messages = frappe.get_all(\"AI Chat Message\",\n            filters={\"session\": session_id},\n            fields=[\"name\", \"role\", \"content\", \"timestamp\", \"command_executed\", \n                   \"command_result\", \"is_error\", \"execution_time\"],\n            order_by=\"timestamp asc\"\n        )\n        \n        return {\"success\": True, \"messages\": messages}\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Get Chat Messages Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get chat messages: {0}\").format(str(e)))","size_bytes":19415},"ai_assistant/config/__init__.py":{"content":"","size_bytes":0},"ai_assistant/config/desktop.py":{"content":"from frappe import _\n\ndef get_data():\n\treturn [\n\t\t{\n\t\t\t\"module_name\": \"AI Assistant\",\n\t\t\t\"color\": \"grey\",\n\t\t\t\"icon\": \"fa fa-robot\",\n\t\t\t\"type\": \"module\",\n\t\t\t\"label\": _(\"AI Assistant\")\n\t\t}\n\t]","size_bytes":189},"attached_assets/BenchChatAI/hooks.py":{"content":"from . import __version__ as app_version\n\napp_name = \"ai_assistant\"\napp_title = \"AI Assistant\"\napp_publisher = \"ERPNext\"\napp_description = \"AI Assistant for ERPNext with intelligent chat and database interactions\"\napp_email = \"support@erpnext.com\"\napp_license = \"MIT\"\n\n# Includes in <head>\n# ------------------\n\n# include js, css files in header of desk.html\n# app_include_css = \"/assets/ai_assistant/css/ai_assistant.css\"\n# app_include_js = \"/assets/ai_assistant/js/ai_assistant.js\"\n\n# include js, css files in header of web template\n# web_include_css = \"/assets/ai_assistant/css/ai_assistant.css\"\n# web_include_js = \"/assets/ai_assistant/js/ai_assistant.js\"\n\n# include custom scss in every website theme (without file extension \".scss\")\n# website_theme_scss = \"ai_assistant/public/scss/website\"\n\n# include js, css files in header of web form\n# webform_include_js = {\"doctype\": \"public/js/doctype.js\"}\n# webform_include_css = {\"doctype\": \"public/css/doctype.css\"}\n\n# include js in page\n# page_js = {\"page\" : \"public/js/file.js\"}\n\n# include js in doctype views\n# doctype_js = {\"doctype\" : \"public/js/doctype.js\"}\n# doctype_list_js = {\"doctype\" : \"public/js/doctype_list.js\"}\n# doctype_tree_js = {\"doctype\" : \"public/js/doctype_tree.js\"}\n# doctype_calendar_js = {\"doctype\" : \"public/js/doctype_calendar.js\"}\n\n# Home Pages\n# ----------\n\n# application home page (will override Website Settings)\n# home_page = \"login\"\n\n# website user home page (by Role)\n# role_home_page = {\n#\t\"Role\": \"home_page\"\n# }\n\n# Generators\n# ----------\n\n# automatically create page for each record of this doctype\n# website_generators = [\"Web Page\"]\n\n# Installation\n# ------------\n\n# before_install = \"ai_assistant.install.before_install\"\n# after_install = \"ai_assistant.install.after_install\"\n\n# Desk Notifications\n# ------------------\n# See frappe.core.notifications.get_notification_config\n\n# notification_config = \"ai_assistant.notifications.get_notification_config\"\n\n# Permissions\n# -----------\n# Permissions evaluated in scripted ways\n\n# permission_query_conditions = {\n#\t\"Event\": \"frappe.desk.doctype.event.event.get_permission_query_conditions\",\n# }\n#\n# has_permission = {\n#\t\"Event\": \"frappe.desk.doctype.event.event.has_permission\",\n# }\n\n# DocType Class\n# ---------------\n# Override standard doctype classes\n\n# override_doctype_class = {\n#\t\"ToDo\": \"custom_app.overrides.CustomToDo\"\n# }\n\n# Document Events\n# ---------------\n# Hook on document methods and events\n\n# doc_events = {\n#\t\"*\": {\n#\t\t\"on_update\": \"method\",\n#\t\t\"on_cancel\": \"method\",\n#\t\t\"on_trash\": \"method\"\n#\t}\n# }\n\n# Scheduled Tasks\n# ---------------\n\n# scheduler_events = {\n#\t\"all\": [\n#\t\t\"ai_assistant.tasks.all\"\n#\t],\n#\t\"daily\": [\n#\t\t\"ai_assistant.tasks.daily\"\n#\t],\n#\t\"hourly\": [\n#\t\t\"ai_assistant.tasks.hourly\"\n#\t],\n#\t\"weekly\": [\n#\t\t\"ai_assistant.tasks.weekly\"\n#\t]\n#\t\"monthly\": [\n#\t\t\"ai_assistant.tasks.monthly\"\n#\t]\n# }\n\n# Testing\n# -------\n\n# before_tests = \"ai_assistant.install.before_tests\"\n\n# Overriding Methods\n# ------------------------------\n#\n# override_whitelisted_methods = {\n#\t\"frappe.desk.doctype.event.event.get_events\": \"ai_assistant.event.get_events\"\n# }\n#\n# each overriding function accepts a `data` argument;\n# generated from the base implementation of the doctype dashboard,\n# along with any modifications made in other Frappe apps\n# override_doctype_dashboards = {\n#\t\"Task\": \"ai_assistant.task.get_dashboard_data\"\n# }\n\n# exempt linked doctypes from being automatically cancelled\n#\n# auto_cancel_exempted_doctypes = [\"Auto Repeat\"]\n\n\n# User Data Protection\n# --------------------\n\n# user_data_fields = [\n#\t{\n#\t\t\"doctype\": \"{doctype_1}\",\n#\t\t\"filter_by\": \"{filter_by}\",\n#\t\t\"redact_fields\": [\"{field_1}\", \"{field_2}\"],\n#\t\t\"partial\": 1,\n#\t},\n#\t{\n#\t\t\"doctype\": \"{doctype_2}\",\n#\t\t\"filter_by\": \"{filter_by}\",\n#\t\t\"partial\": 1,\n#\t},\n#\t{\n#\t\t\"doctype\": \"{doctype_3}\",\n#\t\t\"strict\": False,\n#\t},\n#\t{\n#\t\t\"doctype\": \"{doctype_4}\"\n#\t}\n# ]\n\n# Authentication and authorization\n# --------------------------------\n\n# auth_hooks = [\n#\t\"ai_assistant.auth.validate\"\n# ]\n\n# Translation\n# --------------------------------\n\n# Make link fields search translated document names for these DocTypes\n# Recommended only for DocTypes which have limited documents with untranslated names\n# For example: Role, Gender, etc.\n# translated_search_doctypes = []","size_bytes":4278},"attached_assets/BenchChatAI/replit.md":{"content":"# Overview\n\nThis is an ERPNext AI Assistant application that provides a natural language interface for interacting with ERPNext databases. The system combines a React-based frontend with an Express backend, integrated with Ollama for AI-powered chat functionality and database operations. Users can ask questions in natural language and receive intelligent responses, with the AI analyzing and executing appropriate ERPNext commands while maintaining safety guardrails.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: React with TypeScript using Vite as the build tool\n- **UI Library**: Shadcn/ui components built on Radix UI primitives with Tailwind CSS styling\n- **State Management**: TanStack Query for server state management and React hooks for local state\n- **Routing**: Wouter for client-side routing\n- **Real-time Communication**: WebSocket connection for live chat functionality\n\n## Backend Architecture\n- **Framework**: Express.js with TypeScript, running on Node.js\n- **API Design**: RESTful endpoints with WebSocket support for real-time chat\n- **Data Layer**: Drizzle ORM with PostgreSQL database support\n- **Command Execution**: ERPNext service for executing bench commands safely\n- **AI Integration**: Ollama service for natural language processing and command generation\n\n## Database Design\n- **Primary Database**: PostgreSQL with Drizzle ORM for application data\n- **Schema Management**: Automated migrations with drizzle-kit\n- **Core Tables**: Users, chat messages, database schema cache, and application settings\n- **ERPNext Integration**: Direct command execution against ERPNext instances via bench CLI\n\n## AI and NLP Architecture\n- **AI Provider**: Ollama for local LLM inference\n- **Command Analysis**: Multi-step process including safety validation, command generation, and execution confirmation\n- **Context Management**: Database schema scanning and caching for informed AI responses\n- **Safety Features**: Destructive operation detection, confirmation workflows, and safe mode enforcement\n\n## Real-time Communication\n- **WebSocket Server**: Integrated with Express HTTP server for bidirectional communication\n- **Message Types**: Chat messages, command confirmations, database scans, and settings updates\n- **Connection Management**: Client connection tracking with automatic reconnection support\n\n## Security and Safety\n- **Command Validation**: Input sanitization and command structure validation before execution\n- **Safe Mode**: Configurable safety restrictions for destructive operations\n- **Confirmation Flows**: User approval required for potentially dangerous database operations\n- **Timeout Protection**: Command execution timeouts to prevent hanging operations\n\n# External Dependencies\n\n## Core Infrastructure\n- **Database**: PostgreSQL via Neon serverless database (@neondatabase/serverless)\n- **ORM**: Drizzle ORM for database operations and schema management\n- **Build Tools**: Vite for frontend bundling, esbuild for backend compilation\n\n## AI and Machine Learning\n- **Ollama**: Local LLM server for natural language processing and command generation\n- **Models**: Configurable model support (default: llama2) for different AI capabilities\n\n## UI and Styling\n- **Radix UI**: Comprehensive set of unstyled, accessible UI components\n- **Tailwind CSS**: Utility-first CSS framework for responsive design\n- **Lucide React**: Icon library for consistent visual elements\n\n## Development and Deployment\n- **TypeScript**: Full-stack type safety and improved developer experience\n- **ESLint/Prettier**: Code quality and formatting tools\n- **Replit Integration**: Development environment plugins and optimizations\n\n## ERPNext Integration\n- **Bench CLI**: Direct integration with ERPNext's command-line interface\n- **Frappe Framework**: Underlying framework commands for database operations and system management\n- **Site Management**: Multi-site support with configurable site targeting","size_bytes":4014},"attached_assets/BenchChatAI/setup.py":{"content":"from setuptools import setup, find_packages\n\nwith open(\"requirements.txt\") as f:\n\tinstall_requires = f.read().strip().split(\"\\n\")\n\n# get version from __version__ variable in ai_assistant/__init__.py\nfrom ai_assistant import __version__ as version\n\nsetup(\n\tname=\"ai_assistant\",\n\tversion=version,\n\tdescription=\"AI Assistant for ERPNext with intelligent chat and database interactions\",\n\tauthor=\"ERPNext\",\n\tauthor_email=\"support@erpnext.com\",\n\tpackages=find_packages(),\n\tzip_safe=False,\n\tinclude_package_data=True,\n\tinstall_requires=install_requires\n)","size_bytes":548},"ai_assistant/ai_assistant/doctype/__init__.py":{"content":"","size_bytes":0},"ai_assistant/ai_assistant/services/__init__.py":{"content":"# AI Assistant Services Module\n# \n# This module contains the core services for the AI Assistant ERPNext app:\n# - ollama.py: Ollama API integration for AI model interactions\n# - erpnext_exec.py: Secure command execution service\n# - schema.py: Database schema scanning and context building\n\n__version__ = \"1.0.0\"","size_bytes":310},"ai_assistant/ai_assistant/services/erpnext_exec.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport re\nimport time\nimport subprocess\nimport json\nimport shlex\nimport frappe\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom frappe import _\nfrom frappe.utils import cint, flt\nfrom .erpnext_api import ERPNextAPIService\n\n\nclass ERPNextExecutor:\n    \"\"\"\n    Secure command execution service for AI Assistant.\n    \n    Handles safe execution of database queries and limited system commands\n    with comprehensive security checks and safe mode enforcement.\n    \"\"\"\n    \n    # SQL commands that are allowed\n    ALLOWED_SQL_COMMANDS = {\n        'SELECT', 'SHOW', 'DESCRIBE', 'DESC', 'EXPLAIN'\n    }\n    \n    # Destructive SQL commands that require confirmation\n    DESTRUCTIVE_SQL_COMMANDS = {\n        'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER', \n        'TRUNCATE', 'REPLACE', 'MERGE', 'CALL', 'EXECUTE'\n    }\n    \n    # Allowed bench commands (expanded for useful ERPNext operations)\n    ALLOWED_BENCH_COMMANDS = {\n        # Information commands\n        'version', '--version', '--help', '-h', 'help',\n        'list-apps', 'get-config', 'site-info',\n        \n        # Document operations\n        'get-doc', 'set-value', 'list-docs', 'get-value',\n        'new-doc', 'delete-doc',\n        \n        # Database operations (safe)\n        'mariadb', 'execute', 'console',\n        \n        # Data operations\n        'export-csv', 'export-json', 'import-csv', 'import-json',\n        \n        # ERPNext-specific operations\n        'show-config', 'doctor', 'ready-for-migration',\n        \n        # User and permission operations\n        'add-user', 'set-admin-password', 'disable-user', 'list-users'\n    }\n    \n    # Admin-only commands that are NEVER allowed (even if safe mode is off)\n    BLOCKED_ADMIN_COMMANDS = {\n        'migrate', 'rollback-migration', 'clear-cache', 'clear-website-cache',\n        'backup', 'restore', 'install-app', 'uninstall-app', 'update', 'pull',\n        'setup', 'new-site', 'drop-site', 'reinstall', 'bench-update',\n        'restart', 'start', 'stop', 'reload-nginx', 'setup-nginx'\n    }\n    \n    # Shell metacharacters to detect and block\n    SHELL_METACHARACTERS = {\n        ';', '|', '&', '$', '`', '>', '<', '*', '?', '[', ']', \n        '(', ')', '{', '}', '\\\\', '\"', \"'\", '\\n', '\\r'\n    }\n    \n    def __init__(self, safe_mode: bool = True, timeout: int = 30):\n        \"\"\"\n        Initialize ERPNext command executor.\n        \n        Args:\n            safe_mode (bool): Enable safe mode restrictions\n            timeout (int): Command execution timeout in seconds\n        \"\"\"\n        self.safe_mode = safe_mode\n        self.timeout = timeout\n        self.api_service = ERPNextAPIService(use_rest_api=False)  # Use direct Frappe methods by default\n    \n    def execute_command(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a command with security checks.\n        \n        Args:\n            command (str): Command to execute\n        \n        Returns:\n            Dict[str, Any]: Execution result with structure:\n                {\n                    \"success\": bool,\n                    \"output\": str,\n                    \"error\": str,\n                    \"executionTime\": int  # milliseconds\n                }\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Basic validation\n            if not command or not isinstance(command, str):\n                return self._error_result(\"Invalid command\", start_time)\n            \n            command = command.strip()\n            if not command:\n                return self._error_result(\"Empty command\", start_time)\n            \n            # Security checks\n            security_check = self._perform_security_checks(command)\n            if not security_check[\"safe\"]:\n                return self._error_result(security_check[\"reason\"], start_time)\n            \n            # Determine command type and execute\n            if self._is_sql_command(command):\n                return self._execute_sql_command(command, start_time)\n            elif self._is_api_command(command):\n                return self._execute_api_command(command, start_time)\n            elif self._is_bench_command(command):\n                if self.safe_mode:\n                    return self._error_result(\"Bench commands disabled in safe mode\", start_time)\n                return self._execute_bench_command(command, start_time)\n            else:\n                return self._error_result(\"Command type not recognized or not allowed\", start_time)\n                \n        except Exception as e:\n            frappe.log_error(f\"Command execution error: {str(e)}\", \"ERPNext Executor\")\n            return self._error_result(f\"Execution error: {str(e)}\", start_time)\n    \n    def _perform_security_checks(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Perform comprehensive security checks on command.\n        \n        Args:\n            command (str): Command to check\n        \n        Returns:\n            Dict[str, Any]: Security check result\n        \"\"\"\n        # Check for shell metacharacters\n        for char in self.SHELL_METACHARACTERS:\n            if char in command:\n                return {\n                    \"safe\": False,\n                    \"reason\": f\"Shell metacharacter '{char}' not allowed for security\"\n                }\n        \n        # Check command length\n        if len(command) > 2000:\n            return {\n                \"safe\": False,\n                \"reason\": \"Command too long (max 2000 characters)\"\n            }\n        \n        # Check for suspicious patterns\n        suspicious_patterns = [\n            r'--\\s*$',  # SQL comments at end\n            r'/\\*.*?\\*/',  # SQL block comments\n            r'\\bUNION\\b.*\\bSELECT\\b',  # SQL injection patterns\n            r'\\bEXEC\\b|\\bXP_\\b|\\bSP_\\b',  # System procedures\n            r'\\bFILE\\b|\\bINTO\\s+OUTFILE\\b',  # File operations\n            r'\\bLOAD_FILE\\b|\\bLOAD\\s+DATA\\b',  # File loading\n        ]\n        \n        for pattern in suspicious_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return {\n                    \"safe\": False,\n                    \"reason\": f\"Potentially dangerous pattern detected\"\n                }\n        \n        return {\"safe\": True, \"reason\": \"\"}\n    \n    def _is_sql_command(self, command: str) -> bool:\n        \"\"\"Check if command is a SQL command.\"\"\"\n        first_word = command.strip().split()[0].upper()\n        return first_word in self.ALLOWED_SQL_COMMANDS or first_word in self.DESTRUCTIVE_SQL_COMMANDS\n    \n    def _is_bench_command(self, command: str) -> bool:\n        \"\"\"Check if command is a bench command.\"\"\"\n        return command.strip().startswith('bench ') or command.strip() in self.ALLOWED_BENCH_COMMANDS\n    \n    def _execute_sql_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Execute SQL command using Frappe's database interface.\n        \n        Args:\n            command (str): SQL command to execute\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Execution result\n        \"\"\"\n        try:\n            first_word = command.strip().split()[0].upper()\n            \n            # Check if destructive command\n            if first_word in self.DESTRUCTIVE_SQL_COMMANDS:\n                if self.safe_mode:\n                    return self._error_result(\n                        f\"Destructive SQL command '{first_word}' not allowed in safe mode\", \n                        start_time\n                    )\n                else:\n                    return self._error_result(\n                        f\"Destructive SQL command '{first_word}' requires manual confirmation\", \n                        start_time\n                    )\n            \n            # Process safe SQL commands\n            if first_word == 'SELECT':\n                command = self._add_limit_to_select(command)\n            \n            # Execute using frappe.db.sql\n            if first_word in ['SHOW', 'DESCRIBE', 'DESC']:\n                # These commands return simple results\n                result = frappe.db.sql(command, as_dict=False)\n                output = self._format_sql_result(result)\n            else:\n                # SELECT and EXPLAIN return structured data\n                result = frappe.db.sql(command, as_dict=True)\n                output = self._format_sql_result(result)\n            \n            execution_time = int((time.time() - start_time) * 1000)\n            \n            return {\n                \"success\": True,\n                \"output\": output,\n                \"error\": \"\",\n                \"executionTime\": execution_time\n            }\n            \n        except Exception as e:\n            error_msg = str(e)\n            frappe.log_error(f\"SQL execution error: {error_msg}\", \"ERPNext Executor\")\n            return self._error_result(f\"SQL error: {error_msg}\", start_time)\n    \n    def _execute_bench_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Execute allowed bench command using subprocess.\n        \n        Args:\n            command (str): Bench command to execute\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Execution result\n        \"\"\"\n        try:\n            # Parse command\n            if command.startswith('bench '):\n                cmd_parts = shlex.split(command)\n            else:\n                cmd_parts = ['bench'] + shlex.split(command)\n            \n            # Validate command parts\n            if not self._is_allowed_bench_command(cmd_parts[1:]):\n                return self._error_result(\"Bench command not allowed\", start_time)\n            \n            # Execute with timeout\n            result = subprocess.run(\n                cmd_parts,\n                capture_output=True,\n                text=True,\n                timeout=self.timeout,\n                cwd=frappe.get_site_path('..')\n            )\n            \n            execution_time = int((time.time() - start_time) * 1000)\n            \n            if result.returncode == 0:\n                return {\n                    \"success\": True,\n                    \"output\": result.stdout,\n                    \"error\": result.stderr if result.stderr else \"\",\n                    \"executionTime\": execution_time\n                }\n            else:\n                return {\n                    \"success\": False,\n                    \"output\": result.stdout if result.stdout else \"\",\n                    \"error\": result.stderr if result.stderr else \"Command failed\",\n                    \"executionTime\": execution_time\n                }\n                \n        except subprocess.TimeoutExpired:\n            return self._error_result(\"Command timed out\", start_time)\n        except subprocess.CalledProcessError as e:\n            return self._error_result(f\"Command failed: {str(e)}\", start_time)\n        except Exception as e:\n            frappe.log_error(f\"Bench command error: {str(e)}\", \"ERPNext Executor\")\n            return self._error_result(f\"Execution error: {str(e)}\", start_time)\n    \n    def _is_allowed_bench_command(self, cmd_parts: List[str]) -> bool:\n        \"\"\"Check if bench command parts are allowed.\"\"\"\n        if not cmd_parts:\n            return False\n        \n        # Check first argument\n        first_arg = cmd_parts[0]\n        \n        # Block admin commands immediately\n        if first_arg in self.BLOCKED_ADMIN_COMMANDS:\n            return False\n        \n        # Check if command is in allowed list\n        if first_arg in self.ALLOWED_BENCH_COMMANDS:\n            return True\n        \n        # Allow specific patterns and complex commands\n        safe_patterns = [\n            r'^--help$', r'^-h$', r'^version$', r'^--version$',\n            r'^--site$',  # Allow site specification\n        ]\n        \n        for pattern in safe_patterns:\n            if re.match(pattern, first_arg):\n                return True\n        \n        # Handle complex bench commands with site specification\n        if len(cmd_parts) >= 3 and cmd_parts[0] == '--site':\n            # Allow: bench --site [site_name] [command]\n            actual_command = cmd_parts[2]\n            if actual_command in self.ALLOWED_BENCH_COMMANDS and actual_command not in self.BLOCKED_ADMIN_COMMANDS:\n                return True\n        \n        return False\n    \n    def _is_api_command(self, command: str) -> bool:\n        \"\"\"Check if this is an API command (create, read, update, delete documents).\"\"\"\n        command_lower = command.lower().strip()\n        \n        # API command patterns\n        api_patterns = [\n            \"create \", \"new \", \"insert \",  # Create operations\n            \"get \", \"read \", \"fetch \", \"find \",  # Read operations  \n            \"update \", \"modify \", \"edit \",  # Update operations\n            \"delete \", \"remove \",  # Delete operations\n            \"list \", \"search \"  # List/search operations\n        ]\n        \n        for pattern in api_patterns:\n            if command_lower.startswith(pattern):\n                return True\n        \n        return False\n    \n    def _execute_api_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Execute API command for document operations.\n        \n        Args:\n            command (str): API command to execute\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Execution result\n        \"\"\"\n        try:\n            command_lower = command.lower().strip()\n            \n            # Parse command and determine operation\n            if command_lower.startswith((\"create \", \"new \", \"insert \")):\n                return self._handle_create_command(command, start_time)\n            elif command_lower.startswith((\"get \", \"read \", \"fetch \", \"find \")):\n                return self._handle_read_command(command, start_time)\n            elif command_lower.startswith((\"update \", \"modify \", \"edit \")):\n                return self._handle_update_command(command, start_time)\n            elif command_lower.startswith((\"delete \", \"remove \")):\n                return self._handle_delete_command(command, start_time)\n            elif command_lower.startswith((\"list \", \"search \")):\n                return self._handle_list_command(command, start_time)\n            else:\n                return self._error_result(\"API command not recognized\", start_time)\n                \n        except Exception as e:\n            frappe.log_error(f\"API command error: {str(e)}\", \"ERPNext Executor\")\n            return self._error_result(f\"API execution error: {str(e)}\", start_time)\n    \n    def _handle_create_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"Handle create document commands.\"\"\"\n        # Parse: create Customer with customer_name=\"ABC Corp\" and customer_type=\"Company\"\n        try:\n            parts = command.split()\n            if len(parts) < 2:\n                return self._error_result(\"Invalid create command format\", start_time)\n            \n            doctype = parts[1]\n            \n            # Simple parsing for key=value pairs\n            data = {}\n            if \"with\" in command:\n                with_part = command.split(\"with\", 1)[1].strip()\n                # Parse key=\"value\" pairs\n                import re\n                matches = re.findall(r'(\\w+)=(?:\"([^\"]*)\"|\\'([^\\']*)\\'|(\\S+))', with_part)\n                for match in matches:\n                    key = match[0]\n                    value = match[1] or match[2] or match[3]\n                    data[key] = value\n            \n            result = self.api_service.create_document(doctype, data)\n            execution_time = int((time.time() - start_time) * 1000)\n            result[\"executionTime\"] = execution_time\n            \n            return result\n            \n        except Exception as e:\n            return self._error_result(f\"Create command error: {str(e)}\", start_time)\n    \n    def _handle_read_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"Handle read document commands.\"\"\"\n        # Parse: get Customer \"CUST-00001\" or find Customer where customer_name=\"ABC Corp\"\n        try:\n            parts = command.split()\n            if len(parts) < 2:\n                return self._error_result(\"Invalid read command format\", start_time)\n            \n            doctype = parts[1]\n            \n            # Simple name-based lookup\n            if len(parts) >= 3 and not parts[2].startswith(\"where\"):\n                name = parts[2].strip('\"\\'')\n                result = self.api_service.get_document(doctype, name)\n            else:\n                # List with basic filters\n                filters = {}\n                if \"where\" in command:\n                    # Simple parsing - this could be enhanced\n                    result = self.api_service.list_documents(doctype, filters, limit=10)\n                else:\n                    result = self.api_service.list_documents(doctype, limit=10)\n            \n            execution_time = int((time.time() - start_time) * 1000)\n            result[\"executionTime\"] = execution_time\n            \n            return result\n            \n        except Exception as e:\n            return self._error_result(f\"Read command error: {str(e)}\", start_time)\n    \n    def _handle_update_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"Handle update document commands.\"\"\"\n        # Parse: update Customer \"CUST-00001\" set customer_name=\"New Name\"\n        try:\n            parts = command.split()\n            if len(parts) < 4:\n                return self._error_result(\"Invalid update command format\", start_time)\n            \n            doctype = parts[1]\n            name = parts[2].strip('\"\\'')\n            \n            # Parse set clauses\n            data = {}\n            if \"set\" in command:\n                set_part = command.split(\"set\", 1)[1].strip()\n                import re\n                matches = re.findall(r'(\\w+)=(?:\"([^\"]*)\"|\\'([^\\']*)\\'|(\\S+))', set_part)\n                for match in matches:\n                    key = match[0]\n                    value = match[1] or match[2] or match[3]\n                    data[key] = value\n            \n            result = self.api_service.update_document(doctype, name, data)\n            execution_time = int((time.time() - start_time) * 1000)\n            result[\"executionTime\"] = execution_time\n            \n            return result\n            \n        except Exception as e:\n            return self._error_result(f\"Update command error: {str(e)}\", start_time)\n    \n    def _handle_delete_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"Handle delete document commands.\"\"\"\n        # Parse: delete Customer \"CUST-00001\"\n        try:\n            parts = command.split()\n            if len(parts) < 3:\n                return self._error_result(\"Invalid delete command format\", start_time)\n            \n            doctype = parts[1]\n            name = parts[2].strip('\"\\'')\n            \n            result = self.api_service.delete_document(doctype, name)\n            execution_time = int((time.time() - start_time) * 1000)\n            result[\"executionTime\"] = execution_time\n            \n            return result\n            \n        except Exception as e:\n            return self._error_result(f\"Delete command error: {str(e)}\", start_time)\n    \n    def _handle_list_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"Handle list/search document commands.\"\"\"\n        # Parse: list Customer or search Customer for \"ABC\"\n        try:\n            parts = command.split()\n            if len(parts) < 2:\n                return self._error_result(\"Invalid list command format\", start_time)\n            \n            command_lower = command.lower()\n            doctype = parts[1]\n            \n            if command_lower.startswith(\"search\") and \"for\" in command:\n                # Search command\n                search_term = command.split(\"for\", 1)[1].strip().strip('\"\\'')\n                result = self.api_service.search_documents(doctype, search_term, limit=10)\n            else:\n                # List command\n                filters = {}\n                # Could add filter parsing here\n                result = self.api_service.list_documents(doctype, filters, limit=20)\n            \n            execution_time = int((time.time() - start_time) * 1000)\n            result[\"executionTime\"] = execution_time\n            \n            return result\n            \n        except Exception as e:\n            return self._error_result(f\"List command error: {str(e)}\", start_time)\n    \n    def _add_limit_to_select(self, command: str) -> str:\n        \"\"\"\n        Add LIMIT clause to SELECT queries if not present.\n        \n        Args:\n            command (str): SQL SELECT command\n        \n        Returns:\n            str: Modified command with LIMIT\n        \"\"\"\n        # Check if LIMIT already exists\n        if re.search(r'\\bLIMIT\\b', command, re.IGNORECASE):\n            return command\n        \n        # Add LIMIT 100 at the end\n        command = command.rstrip(';').rstrip()\n        return f\"{command} LIMIT 100\"\n    \n    def _format_sql_result(self, result: Any) -> str:\n        \"\"\"\n        Format SQL result for display.\n        \n        Args:\n            result: SQL query result\n        \n        Returns:\n            str: Formatted result string\n        \"\"\"\n        if not result:\n            return \"No results found.\"\n        \n        try:\n            if isinstance(result, list):\n                if len(result) == 0:\n                    return \"No results found.\"\n                \n                # Check if it's a list of dictionaries (as_dict=True)\n                if isinstance(result[0], dict):\n                    # Format as JSON for structured data\n                    return json.dumps(result, indent=2, default=str)\n                else:\n                    # Format as simple table for tuple results\n                    output = []\n                    for row in result:\n                        if isinstance(row, (tuple, list)):\n                            output.append(\" | \".join(str(col) for col in row))\n                        else:\n                            output.append(str(row))\n                    return \"\\n\".join(output)\n            else:\n                return str(result)\n                \n        except Exception as e:\n            frappe.log_error(f\"Result formatting error: {str(e)}\", \"ERPNext Executor\")\n            return f\"Result formatting error: {str(e)}\"\n    \n    def _error_result(self, error_message: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Create error result dictionary.\n        \n        Args:\n            error_message (str): Error message\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Error result\n        \"\"\"\n        execution_time = int((time.time() - start_time) * 1000)\n        return {\n            \"success\": False,\n            \"output\": \"\",\n            \"error\": error_message,\n            \"executionTime\": execution_time\n        }\n    \n    def validate_sql_query(self, query: str) -> Dict[str, Any]:\n        \"\"\"\n        Validate SQL query without executing it.\n        \n        Args:\n            query (str): SQL query to validate\n        \n        Returns:\n            Dict[str, Any]: Validation result\n        \"\"\"\n        try:\n            # Basic syntax check\n            query = query.strip()\n            if not query:\n                return {\"valid\": False, \"reason\": \"Empty query\"}\n            \n            # Check command type\n            first_word = query.split()[0].upper()\n            \n            if first_word in self.DESTRUCTIVE_SQL_COMMANDS:\n                return {\n                    \"valid\": False,\n                    \"reason\": f\"Destructive command '{first_word}' not allowed\",\n                    \"isDestructive\": True\n                }\n            \n            if first_word not in self.ALLOWED_SQL_COMMANDS:\n                return {\n                    \"valid\": False,\n                    \"reason\": f\"Command '{first_word}' not allowed\"\n                }\n            \n            # Security checks\n            security_check = self._perform_security_checks(query)\n            if not security_check[\"safe\"]:\n                return {\n                    \"valid\": False,\n                    \"reason\": security_check[\"reason\"]\n                }\n            \n            return {\n                \"valid\": True,\n                \"reason\": \"Query is valid\",\n                \"commandType\": first_word.lower(),\n                \"isDestructive\": False\n            }\n            \n        except Exception as e:\n            return {\n                \"valid\": False,\n                \"reason\": f\"Validation error: {str(e)}\"\n            }\n\n\ndef get_executor(safe_mode: Optional[bool] = None) -> ERPNextExecutor:\n    \"\"\"\n    Get ERPNext executor with settings from AI Assistant Settings.\n    \n    Args:\n        safe_mode (Optional[bool]): Override safe mode setting\n    \n    Returns:\n        ERPNextExecutor: Configured executor instance\n    \"\"\"\n    try:\n        if safe_mode is None:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            safe_mode = settings.safe_mode\n        \n        return ERPNextExecutor(safe_mode=safe_mode)\n    except Exception as e:\n        frappe.log_error(f\"Failed to get executor: {str(e)}\", \"ERPNext Executor\")\n        # Return default safe configuration\n        return ERPNextExecutor(safe_mode=True)","size_bytes":25650},"ai_assistant/ai_assistant/services/ollama.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport re\nimport requests\nimport os\nfrom typing import Dict, Any, Optional\n\n# Try to import frappe, but handle case where it's not available\ntry:\n    import frappe\n    from frappe import _\n    from frappe.utils import cint\nexcept ImportError:\n    # Fallback for standalone testing\n    frappe = None\n    def _(text): return text\n    def cint(val): return int(val) if val else 0\n\n# Import OpenAI if available\ntry:\n    from openai import OpenAI\nexcept ImportError:\n    OpenAI = None\n\n\nclass AIService:\n    \"\"\"\n    Unified AI service class for interacting with both Ollama and OpenAI APIs.\n    \n    Provides methods for generating AI responses and analyzing commands\n    for the AI Assistant ERPNext application.\n    \"\"\"\n    \n    def __init__(self, provider: str = \"ollama\", url: str = \"http://localhost:11434\", model: str = \"llama2\", timeout: int = 30, openai_api_key: str = None):\n        \"\"\"\n        Initialize AI service.\n        \n        Args:\n            provider (str): AI provider ('ollama' or 'openai')\n            url (str): Ollama server URL (only used for Ollama)\n            model (str): AI model name\n            timeout (int): Request timeout in seconds\n            openai_api_key (str): OpenAI API key (only used for OpenAI)\n        \"\"\"\n        self.provider = provider.lower()\n        self.url = url.rstrip('/') if url else \"\"\n        self.model = model\n        self.timeout = timeout\n        \n        if self.provider == \"openai\":\n            # Initialize OpenAI client\n            api_key = openai_api_key or os.environ.get(\"OPENAI_API_KEY\")\n            if not api_key:\n                raise ValueError(\"OpenAI API key is required for OpenAI provider\")\n            if OpenAI is None:\n                raise ImportError(\"OpenAI package not installed. Run: pip install openai\")\n            self.openai_client = OpenAI(api_key=api_key)\n        else:\n            # Initialize Ollama session\n            self.session = requests.Session()\n            self.session.headers.update({\n                'Content-Type': 'application/json',\n                'User-Agent': 'ERPNext-AI-Assistant/1.0'\n            })\n    \n    def generate_response(self, prompt: str, schema_context: str = \"\") -> str:\n        \"\"\"\n        Generate AI response for given prompt.\n        \n        Args:\n            prompt (str): User prompt/question\n            schema_context (str): Database schema context for better responses\n        \n        Returns:\n            str: AI generated response\n        \n        Raises:\n            Exception: If API call fails or times out\n        \"\"\"\n        try:\n            if self.provider == \"openai\":\n                return self._generate_openai_response(prompt, schema_context)\n            else:\n                return self._generate_ollama_response(prompt, schema_context)\n        except Exception as e:\n            error_msg = f\"AI response generation failed: {str(e)}\"\n            if frappe:\n                frappe.log_error(error_msg, \"AI Service\")\n            raise Exception(error_msg)\n    \n    def _generate_ollama_response(self, prompt: str, schema_context: str = \"\") -> str:\n        \"\"\"Generate response using Ollama API.\"\"\"\n        try:\n            # Build context-aware prompt\n            system_prompt = self._build_system_prompt(schema_context)\n            full_prompt = f\"{system_prompt}\\n\\nUser: {prompt}\\nAssistant:\"\n            \n            payload = {\n                \"model\": self.model,\n                \"prompt\": full_prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"temperature\": 0.7,\n                    \"max_tokens\": 1000,\n                    \"stop\": [\"User:\", \"Human:\"]\n                }\n            }\n            \n            response = self.session.post(\n                f\"{self.url}/api/generate\",\n                json=payload,\n                timeout=self.timeout\n            )\n            \n            if response.status_code == 200:\n                result = response.json()\n                return result.get('response', '').strip()\n            else:\n                error_msg = f\"Ollama API returned {response.status_code}: {response.text}\"\n                if frappe:\n                    frappe.log_error(error_msg, \"Ollama Service\")\n                raise Exception(f\"Failed to generate response: {error_msg}\")\n                \n        except requests.exceptions.Timeout:\n            if frappe:\n                frappe.log_error(\"Ollama API timeout\", \"Ollama Service\")\n            raise Exception(\"AI service is taking too long to respond. Please try again.\")\n        except requests.exceptions.ConnectionError:\n            if frappe:\n                frappe.log_error(f\"Cannot connect to Ollama at {self.url}\", \"Ollama Service\")\n            raise Exception(f\"Cannot connect to AI service at {self.url}. Please check if Ollama is running.\")\n        except requests.exceptions.RequestException as e:\n            if frappe:\n                frappe.log_error(f\"Ollama API request error: {str(e)}\", \"Ollama Service\")\n            raise Exception(f\"AI service error: {str(e)}\")\n    \n    def _generate_openai_response(self, prompt: str, schema_context: str = \"\") -> str:\n        \"\"\"Generate response using OpenAI API.\"\"\"\n        try:\n            # Build context-aware system message\n            system_prompt = self._build_system_prompt(schema_context)\n            \n            messages = [\n                {\"role\": \"system\", \"content\": system_prompt},\n                {\"role\": \"user\", \"content\": prompt}\n            ]\n            \n            # the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n            # do not change this unless explicitly requested by the user\n            model = self.model if self.model.startswith('gpt-') else 'gpt-5'\n            \n            response = self.openai_client.chat.completions.create(\n                model=model,\n                messages=messages,\n                max_tokens=1000,\n                timeout=self.timeout\n            )\n            \n            return response.choices[0].message.content.strip()\n        except Exception as e:\n            if frappe:\n                frappe.log_error(f\"OpenAI API error: {str(e)}\", \"AI Service\")\n            raise Exception(f\"OpenAI API error: {str(e)}\")\n    \n    def analyze_command(self, prompt: str, schema_context: str = \"\") -> Dict[str, Any]:\n        \"\"\"\n        Analyze if a prompt contains a command that should be executed.\n        \n        Args:\n            prompt (str): User prompt to analyze\n            schema_context (str): Database schema context\n        \n        Returns:\n            Dict[str, Any]: Command analysis with structure:\n                {\n                    \"command\": str,\n                    \"description\": str,\n                    \"isDestructive\": bool,\n                    \"requiresConfirmation\": bool,\n                    \"category\": str\n                }\n        \"\"\"\n        try:\n            if self.provider == \"openai\":\n                return self._analyze_command_openai(prompt, schema_context)\n            else:\n                return self._analyze_command_ollama(prompt, schema_context)\n        except Exception as e:\n            if frappe:\n                frappe.log_error(f\"Command analysis error: {str(e)}\", \"AI Service\")\n            return self._default_command_analysis()\n    \n    def _analyze_command_ollama(self, prompt: str, schema_context: str = \"\") -> Dict[str, Any]:\n        \"\"\"Analyze command using Ollama.\"\"\"\n        analysis_prompt = self._build_command_analysis_prompt(prompt, schema_context)\n        \n        payload = {\n            \"model\": self.model,\n            \"prompt\": analysis_prompt,\n            \"stream\": False,\n            \"options\": {\n                \"temperature\": 0.1,  # Lower temperature for more consistent JSON\n                \"max_tokens\": 500\n            }\n        }\n        \n        response = self.session.post(\n            f\"{self.url}/api/generate\",\n            json=payload,\n            timeout=self.timeout\n        )\n        \n        if response.status_code == 200:\n            result = response.json()\n            response_text = result.get('response', '').strip()\n            \n            # Extract JSON from response\n            command_analysis = self.extract_json_from_response(response_text)\n            \n            # Validate and set defaults\n            return self._validate_command_analysis(command_analysis)\n        else:\n            if frappe:\n                frappe.log_error(f\"Command analysis API error: {response.status_code} - {response.text}\", \"AI Service\")\n            return self._default_command_analysis()\n    \n    def _analyze_command_openai(self, prompt: str, schema_context: str = \"\") -> Dict[str, Any]:\n        \"\"\"Analyze command using OpenAI.\"\"\"\n        analysis_prompt = self._build_command_analysis_prompt(prompt, schema_context)\n        \n        messages = [\n            {\"role\": \"system\", \"content\": analysis_prompt},\n            {\"role\": \"user\", \"content\": prompt}\n        ]\n        \n        # the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n        # do not change this unless explicitly requested by the user\n        model = self.model if self.model.startswith('gpt-') else 'gpt-5'\n        \n        response = self.openai_client.chat.completions.create(\n            model=model,\n            messages=messages,\n            response_format={\"type\": \"json_object\"},\n            max_tokens=500,\n            timeout=self.timeout\n        )\n        \n        try:\n            import json\n            analysis_result = json.loads(response.choices[0].message.content)\n            return self._validate_command_analysis(analysis_result)\n        except Exception as e:\n            if frappe:\n                frappe.log_error(f\"OpenAI analysis result parsing error: {str(e)}\", \"AI Service\")\n            return self._default_command_analysis()\n    \n    def extract_json_from_response(self, response_text: str) -> Dict[str, Any]:\n        \"\"\"\n        Extract JSON object from AI response text.\n        \n        Args:\n            response_text (str): Raw AI response text\n        \n        Returns:\n            Dict[str, Any]: Parsed JSON object\n        \"\"\"\n        try:\n            # Try to find JSON block in response\n            json_patterns = [\n                r'```json\\s*(\\{.*?\\})\\s*```',\n                r'```\\s*(\\{.*?\\})\\s*```',\n                r'(\\{.*?\\})',\n                r'JSON:\\s*(\\{.*?\\})'\n            ]\n            \n            for pattern in json_patterns:\n                match = re.search(pattern, response_text, re.DOTALL)\n                if match:\n                    json_str = match.group(1)\n                    try:\n                        return json.loads(json_str)\n                    except json.JSONDecodeError:\n                        continue\n            \n            # If no JSON found, try parsing the entire response\n            return json.loads(response_text)\n            \n        except json.JSONDecodeError:\n            # Return empty dict if JSON parsing fails\n            if frappe:\n                frappe.log_error(f\"Failed to parse JSON from response: {response_text}\", \"AI Service\")\n            return {}\n        except Exception as e:\n            if frappe:\n                frappe.log_error(f\"JSON extraction error: {str(e)}\", \"AI Service\")\n            return {}\n    \n    def _build_system_prompt(self, schema_context: str) -> str:\n        \"\"\"Build system prompt with ERPNext context.\"\"\"\n        base_prompt = \"\"\"You are an AI assistant for ERPNext, an open-source ERP system. You help users with:\n1. Understanding their business data and reports\n2. Writing database queries to extract information\n3. Analyzing business processes and workflows\n4. Suggesting best practices for ERPNext usage\n\nGuidelines:\n- Always prioritize data security and user permissions\n- Suggest only safe, non-destructive operations\n- When writing SQL queries, always include appropriate LIMIT clauses\n- Focus on helping users understand their business data\n- Be concise but comprehensive in your responses\"\"\"\n        \n        if schema_context:\n            base_prompt += f\"\\n\\nDatabase Schema Context:\\n{schema_context}\"\n            \n        return base_prompt\n    \n    def _build_command_analysis_prompt(self, prompt: str, schema_context: str) -> str:\n        \"\"\"Build prompt for command analysis.\"\"\"\n        analysis_prompt = f\"\"\"Analyze the following user request and determine if it contains a command that should be executed in ERPNext.\n\nUser Request: \"{prompt}\"\n\n{schema_context and f\"Database Schema: {schema_context[:1000]}\" or \"\"}\n\nReturn a JSON object with this exact structure:\n{{\n    \"command\": \"extracted command or empty string\",\n    \"description\": \"brief description of what the command does\",\n    \"isDestructive\": false,\n    \"requiresConfirmation\": false,\n    \"category\": \"query|report|analysis|other\"\n}}\n\nCategories:\n- query: Database SELECT queries\n- report: Generate reports or summaries\n- analysis: Data analysis or calculations\n- other: General questions or non-command requests\n\nMark isDestructive as true ONLY for commands that modify data (INSERT, UPDATE, DELETE, CREATE, DROP, ALTER).\nMark requiresConfirmation as true for any potentially risky operations.\n\nExample responses:\nFor \"Show me all customers\": {{\"command\": \"SELECT * FROM `tabCustomer` LIMIT 100\", \"description\": \"List all customers\", \"isDestructive\": false, \"requiresConfirmation\": false, \"category\": \"query\"}}\n\nFor \"What is ERPNext?\": {{\"command\": \"\", \"description\": \"General question about ERPNext\", \"isDestructive\": false, \"requiresConfirmation\": false, \"category\": \"other\"}}\n\nReturn only the JSON object:\"\"\"\n        \n        return analysis_prompt\n    \n    def _validate_command_analysis(self, analysis: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate and normalize command analysis result.\"\"\"\n        return {\n            \"command\": str(analysis.get(\"command\", \"\")),\n            \"description\": str(analysis.get(\"description\", \"No description available\")),\n            \"isDestructive\": bool(analysis.get(\"isDestructive\", False)),\n            \"requiresConfirmation\": bool(analysis.get(\"requiresConfirmation\", False)),\n            \"category\": str(analysis.get(\"category\", \"other\"))\n        }\n    \n    def _default_command_analysis(self) -> Dict[str, Any]:\n        \"\"\"Return default command analysis when parsing fails.\"\"\"\n        return {\n            \"command\": \"\",\n            \"description\": \"Unable to analyze command\",\n            \"isDestructive\": False,\n            \"requiresConfirmation\": False,\n            \"category\": \"other\"\n        }\n    \n    def test_connection(self) -> bool:\n        \"\"\"\n        Test connection to AI service.\n        \n        Returns:\n            bool: True if connection successful, False otherwise\n        \"\"\"\n        try:\n            if self.provider == \"openai\":\n                # Test OpenAI connection with minimal request\n                response = self.openai_client.chat.completions.create(\n                    model=\"gpt-3.5-turbo\",\n                    messages=[{\"role\": \"user\", \"content\": \"test\"}],\n                    max_tokens=1\n                )\n                return True\n            else:\n                # Test Ollama connection\n                response = self.session.get(f\"{self.url}/api/tags\", timeout=5)\n                return response.status_code == 200\n        except Exception as e:\n            if frappe:\n                frappe.log_error(f\"AI service connection test failed: {str(e)}\", \"AI Service\")\n            return False\n    \n    def get_available_models(self) -> list:\n        \"\"\"\n        Get list of available models from AI service.\n        \n        Returns:\n            list: List of available model names\n        \"\"\"\n        try:\n            if self.provider == \"openai\":\n                # Return common OpenAI models\n                return [\"gpt-5\", \"gpt-4o\", \"gpt-4\", \"gpt-3.5-turbo\"]\n            else:\n                # Get Ollama models\n                response = self.session.get(f\"{self.url}/api/tags\", timeout=10)\n                if response.status_code == 200:\n                    data = response.json()\n                    models = data.get('models', [])\n                    return [model.get('name', '') for model in models if model.get('name')]\n                else:\n                    return []\n        except Exception as e:\n            if frappe:\n                frappe.log_error(f\"Failed to get available models: {str(e)}\", \"AI Service\")\n            return []\n\n\ndef get_ollama_service() -> AIService:\n    \"\"\"\n    Get configured AI service instance.\n    \n    Returns:\n        AIService: Configured service instance\n    \"\"\"\n    try:\n        if frappe:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            return AIService(\n                provider=\"ollama\",\n                url=settings.ollama_url or \"http://localhost:11434\",\n                model=settings.model or \"llama2\",\n                timeout=30\n            )\n        else:\n            # Fallback for standalone testing\n            return AIService()\n    except Exception as e:\n        if frappe:\n            frappe.log_error(f\"Failed to get AI service: {str(e)}\", \"AI Service\")\n        # Return default configuration\n        return AIService()","size_bytes":17339},"ai_assistant/ai_assistant/services/schema.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport frappe\nfrom typing import Dict, Any, List, Optional\nfrom frappe import _\nfrom frappe.utils import now_datetime, cint\n\n\nclass SchemaService:\n    \"\"\"\n    Database schema scanning service for AI Assistant.\n    \n    Provides methods to scan and cache database schema information\n    to provide better context for AI responses.\n    \"\"\"\n    \n    @staticmethod\n    def scan_database(include_custom: bool = True, max_tables: int = 100) -> Dict[str, Any]:\n        \"\"\"\n        Scan database schema and return structured information.\n        \n        Args:\n            include_custom (bool): Include custom DocTypes\n            max_tables (int): Maximum number of tables to scan\n        \n        Returns:\n            Dict[str, Any]: Schema information\n        \"\"\"\n        try:\n            schema_info = {\n                \"scan_time\": now_datetime().isoformat(),\n                \"doctypes\": {},\n                \"tables\": {},\n                \"summary\": {\n                    \"total_doctypes\": 0,\n                    \"total_tables\": 0,\n                    \"custom_doctypes\": 0\n                }\n            }\n            \n            # Scan DocTypes using Frappe meta\n            schema_info[\"doctypes\"] = SchemaService._scan_doctypes(include_custom)\n            schema_info[\"summary\"][\"total_doctypes\"] = len(schema_info[\"doctypes\"])\n            \n            # Count custom DocTypes\n            custom_count = sum(1 for dt in schema_info[\"doctypes\"].values() \n                             if dt.get(\"is_custom\", False))\n            schema_info[\"summary\"][\"custom_doctypes\"] = custom_count\n            \n            # Scan raw database tables\n            schema_info[\"tables\"] = SchemaService._scan_database_tables(max_tables)\n            schema_info[\"summary\"][\"total_tables\"] = len(schema_info[\"tables\"])\n            \n            return schema_info\n            \n        except Exception as e:\n            frappe.log_error(f\"Database scan error: {str(e)}\", \"Schema Service\")\n            raise Exception(f\"Failed to scan database: {str(e)}\")\n    \n    @staticmethod\n    def _scan_doctypes(include_custom: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Scan DocTypes using Frappe's meta system.\n        \n        Args:\n            include_custom (bool): Include custom DocTypes\n        \n        Returns:\n            Dict[str, Any]: DocType information\n        \"\"\"\n        doctypes_info = {}\n        \n        try:\n            # Get all DocTypes\n            filters = {}\n            if not include_custom:\n                filters[\"custom\"] = 0\n            \n            doctype_list = frappe.get_all(\"DocType\", \n                filters=filters,\n                fields=[\"name\", \"module\", \"custom\", \"is_single\", \"is_tree\", \n                       \"is_child\", \"is_virtual\", \"description\"],\n                limit_page_length=200\n            )\n            \n            for dt in doctype_list:\n                try:\n                    # Get meta information\n                    meta = frappe.get_meta(dt[\"name\"])\n                    \n                    doctype_info = {\n                        \"name\": dt[\"name\"],\n                        \"module\": dt[\"module\"],\n                        \"is_custom\": bool(dt.get(\"custom\")),\n                        \"is_single\": bool(dt.get(\"is_single\")),\n                        \"is_tree\": bool(dt.get(\"is_tree\")),\n                        \"is_child\": bool(dt.get(\"is_child\")),\n                        \"is_virtual\": bool(dt.get(\"is_virtual\")),\n                        \"description\": dt.get(\"description\", \"\"),\n                        \"fields\": [],\n                        \"links\": []\n                    }\n                    \n                    # Get field information\n                    for field in meta.fields:\n                        if field.fieldtype not in [\"Section Break\", \"Column Break\", \"Tab Break\"]:\n                            field_info = {\n                                \"fieldname\": field.fieldname,\n                                \"fieldtype\": field.fieldtype,\n                                \"label\": field.label,\n                                \"reqd\": bool(field.reqd),\n                                \"options\": field.options if field.options else \"\"\n                            }\n                            doctype_info[\"fields\"].append(field_info)\n                    \n                    # Get link fields for relationships\n                    for field in meta.fields:\n                        if field.fieldtype == \"Link\" and field.options:\n                            doctype_info[\"links\"].append({\n                                \"field\": field.fieldname,\n                                \"target\": field.options,\n                                \"label\": field.label\n                            })\n                    \n                    doctypes_info[dt[\"name\"]] = doctype_info\n                    \n                except Exception as field_error:\n                    frappe.log_error(f\"Error scanning DocType {dt['name']}: {str(field_error)}\", \"Schema Service\")\n                    continue\n            \n            return doctypes_info\n            \n        except Exception as e:\n            frappe.log_error(f\"DocType scan error: {str(e)}\", \"Schema Service\")\n            return {}\n    \n    @staticmethod\n    def _scan_database_tables(max_tables: int = 100) -> Dict[str, Any]:\n        \"\"\"\n        Scan raw database tables using SQL.\n        \n        Args:\n            max_tables (int): Maximum number of tables to scan\n        \n        Returns:\n            Dict[str, Any]: Table information\n        \"\"\"\n        tables_info = {}\n        \n        try:\n            # Get list of tables\n            tables_result = frappe.db.sql(\"SHOW TABLES\", as_dict=False)\n            table_names = [table[0] for table in tables_result[:max_tables]]\n            \n            for table_name in table_names:\n                try:\n                    # Skip certain system tables\n                    if table_name.startswith('__') or table_name in ['mysql', 'information_schema', 'performance_schema']:\n                        continue\n                    \n                    # Get table structure\n                    describe_result = frappe.db.sql(f\"DESCRIBE `{table_name}`\", as_dict=True)\n                    \n                    table_info = {\n                        \"name\": table_name,\n                        \"columns\": [],\n                        \"primary_keys\": [],\n                        \"indexes\": []\n                    }\n                    \n                    # Process columns\n                    for column in describe_result:\n                        column_info = {\n                            \"name\": column.get(\"Field\", \"\"),\n                            \"type\": column.get(\"Type\", \"\"),\n                            \"null\": column.get(\"Null\", \"\") == \"YES\",\n                            \"key\": column.get(\"Key\", \"\"),\n                            \"default\": column.get(\"Default\", \"\"),\n                            \"extra\": column.get(\"Extra\", \"\")\n                        }\n                        table_info[\"columns\"].append(column_info)\n                        \n                        # Track primary keys\n                        if column.get(\"Key\") == \"PRI\":\n                            table_info[\"primary_keys\"].append(column.get(\"Field\"))\n                    \n                    tables_info[table_name] = table_info\n                    \n                except Exception as table_error:\n                    frappe.log_error(f\"Error scanning table {table_name}: {str(table_error)}\", \"Schema Service\")\n                    continue\n            \n            return tables_info\n            \n        except Exception as e:\n            frappe.log_error(f\"Database tables scan error: {str(e)}\", \"Schema Service\")\n            return {}\n    \n    @staticmethod\n    def get_schema_context(format_type: str = \"summary\") -> str:\n        \"\"\"\n        Get cached schema context for AI assistant.\n        \n        Args:\n            format_type (str): Format type - \"summary\", \"detailed\", or \"json\"\n        \n        Returns:\n            str: Formatted schema context\n        \"\"\"\n        try:\n            # Try to get cached schema from settings\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            \n            # Check if we have cached schema (assuming we add a field for this)\n            cached_schema = getattr(settings, 'cached_schema', None)\n            \n            if cached_schema:\n                try:\n                    schema_data = json.loads(cached_schema)\n                    return SchemaService._format_schema_context(schema_data, format_type)\n                except json.JSONDecodeError:\n                    pass\n            \n            # If no cached schema, generate basic context from key DocTypes\n            return SchemaService._generate_basic_context(format_type)\n            \n        except Exception as e:\n            frappe.log_error(f\"Get schema context error: {str(e)}\", \"Schema Service\")\n            return \"Schema context unavailable\"\n    \n    @staticmethod\n    def _generate_basic_context(format_type: str = \"summary\") -> str:\n        \"\"\"Generate basic schema context without full scan.\"\"\"\n        try:\n            # Key ERPNext DocTypes that are commonly queried\n            key_doctypes = [\n                \"Customer\", \"Supplier\", \"Item\", \"Sales Invoice\", \"Purchase Invoice\",\n                \"Sales Order\", \"Purchase Order\", \"Delivery Note\", \"Purchase Receipt\",\n                \"Payment Entry\", \"Journal Entry\", \"Employee\", \"User\", \"Company\"\n            ]\n            \n            context_parts = []\n            \n            if format_type == \"summary\":\n                context_parts.append(\"ERPNext Core Entities:\")\n                \n                for doctype in key_doctypes:\n                    try:\n                        if frappe.db.exists(\"DocType\", doctype):\n                            meta = frappe.get_meta(doctype)\n                            key_fields = [f.fieldname for f in meta.fields[:5] \n                                        if f.fieldtype not in [\"Section Break\", \"Column Break\"]]\n                            \n                            context_parts.append(f\"- {doctype}: {', '.join(key_fields)}\")\n                    except Exception:\n                        continue\n                        \n                return \"\\n\".join(context_parts)\n            \n            elif format_type == \"detailed\":\n                context_parts.append(\"ERPNext Schema Context (Basic):\")\n                \n                for doctype in key_doctypes:\n                    try:\n                        if frappe.db.exists(\"DocType\", doctype):\n                            meta = frappe.get_meta(doctype)\n                            context_parts.append(f\"\\n{doctype}:\")\n                            context_parts.append(f\"  Table: `tab{doctype}`\")\n                            \n                            # Key fields\n                            key_fields = []\n                            for field in meta.fields[:10]:\n                                if field.fieldtype not in [\"Section Break\", \"Column Break\", \"Tab Break\"]:\n                                    key_fields.append(f\"    {field.fieldname} ({field.fieldtype})\")\n                            \n                            if key_fields:\n                                context_parts.append(\"  Key Fields:\")\n                                context_parts.extend(key_fields)\n                    except Exception:\n                        continue\n                        \n                return \"\\n\".join(context_parts)\n            \n            else:  # json format\n                schema_data = {\"doctypes\": []}\n                for doctype in key_doctypes:\n                    try:\n                        if frappe.db.exists(\"DocType\", doctype):\n                            meta = frappe.get_meta(doctype)\n                            fields = [{\"name\": f.fieldname, \"type\": f.fieldtype, \"label\": f.label}\n                                    for f in meta.fields[:10] \n                                    if f.fieldtype not in [\"Section Break\", \"Column Break\"]]\n                            \n                            schema_data[\"doctypes\"].append({\n                                \"name\": doctype,\n                                \"table\": f\"tab{doctype}\",\n                                \"fields\": fields\n                            })\n                    except Exception:\n                        continue\n                \n                return json.dumps(schema_data, indent=2)\n                \n        except Exception as e:\n            frappe.log_error(f\"Generate basic context error: {str(e)}\", \"Schema Service\")\n            return \"Basic schema context unavailable\"\n    \n    @staticmethod\n    def _format_schema_context(schema_data: Dict[str, Any], format_type: str) -> str:\n        \"\"\"Format schema data into context string.\"\"\"\n        try:\n            if format_type == \"json\":\n                return json.dumps(schema_data, indent=2)\n            \n            context_parts = []\n            \n            if format_type == \"summary\":\n                context_parts.append(f\"Database Schema (scanned: {schema_data.get('scan_time', 'unknown')}):\")\n                context_parts.append(f\"DocTypes: {schema_data['summary']['total_doctypes']}\")\n                context_parts.append(f\"Custom DocTypes: {schema_data['summary']['custom_doctypes']}\")\n                context_parts.append(f\"Database Tables: {schema_data['summary']['total_tables']}\")\n                \n                # Key DocTypes summary\n                context_parts.append(\"\\nKey DocTypes:\")\n                for name, info in list(schema_data['doctypes'].items())[:10]:\n                    field_count = len(info.get('fields', []))\n                    context_parts.append(f\"- {name}: {field_count} fields\")\n                    \n            else:  # detailed\n                context_parts.append(f\"Detailed Schema (scanned: {schema_data.get('scan_time', 'unknown')}):\")\n                \n                # DocTypes details\n                for name, info in list(schema_data['doctypes'].items())[:20]:\n                    context_parts.append(f\"\\n{name}:\")\n                    context_parts.append(f\"  Module: {info.get('module', 'unknown')}\")\n                    context_parts.append(f\"  Custom: {info.get('is_custom', False)}\")\n                    \n                    # Key fields\n                    key_fields = info.get('fields', [])[:8]\n                    if key_fields:\n                        context_parts.append(\"  Fields:\")\n                        for field in key_fields:\n                            req_marker = \" (required)\" if field.get('reqd') else \"\"\n                            context_parts.append(f\"    {field['fieldname']} ({field['fieldtype']}){req_marker}\")\n            \n            return \"\\n\".join(context_parts)\n            \n        except Exception as e:\n            frappe.log_error(f\"Format schema context error: {str(e)}\", \"Schema Service\")\n            return \"Schema formatting error\"\n    \n    @staticmethod\n    def save_schema_to_settings(schema_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Save schema data to AI Assistant Settings.\n        \n        Args:\n            schema_data (Dict[str, Any]): Schema data to save\n        \n        Returns:\n            bool: True if saved successfully\n        \"\"\"\n        try:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            \n            # Convert to JSON string (with size limit)\n            schema_json = json.dumps(schema_data)\n            \n            # Limit size to prevent database issues (e.g., 1MB limit)\n            max_size = 1024 * 1024  # 1MB\n            if len(schema_json) > max_size:\n                # Truncate data while keeping structure\n                truncated_data = {\n                    \"scan_time\": schema_data.get(\"scan_time\"),\n                    \"summary\": schema_data.get(\"summary\", {}),\n                    \"doctypes\": dict(list(schema_data.get(\"doctypes\", {}).items())[:50]),\n                    \"tables\": dict(list(schema_data.get(\"tables\", {}).items())[:50]),\n                    \"truncated\": True\n                }\n                schema_json = json.dumps(truncated_data)\n            \n            # Save to settings - assuming we add a Long Text field called 'cached_schema'\n            settings.db_set('cached_schema', schema_json, update_modified=True)\n            settings.db_set('schema_last_scan', now_datetime(), update_modified=True)\n            \n            return True\n            \n        except Exception as e:\n            frappe.log_error(f\"Save schema error: {str(e)}\", \"Schema Service\")\n            return False\n\n\ndef scan_database_background():\n    \"\"\"\n    Background job function for database scanning.\n    This function is called by frappe.enqueue.\n    \"\"\"\n    try:\n        frappe.logger(\"schema_scan\").info(\"Starting background database scan\")\n        \n        # Perform full scan\n        schema_data = SchemaService.scan_database(include_custom=True, max_tables=200)\n        \n        # Save to settings\n        success = SchemaService.save_schema_to_settings(schema_data)\n        \n        if success:\n            frappe.logger(\"schema_scan\").info(f\"Schema scan completed successfully. \"\n                                            f\"Found {schema_data['summary']['total_doctypes']} DocTypes \"\n                                            f\"and {schema_data['summary']['total_tables']} tables.\")\n        else:\n            frappe.logger(\"schema_scan\").error(\"Failed to save schema scan results\")\n            \n    except Exception as e:\n        frappe.log_error(f\"Background schema scan error: {str(e)}\", \"Schema Background Scan\")\n        frappe.logger(\"schema_scan\").error(f\"Background scan failed: {str(e)}\")\n\n\ndef get_schema_service() -> SchemaService:\n    \"\"\"\n    Get SchemaService instance.\n    \n    Returns:\n        SchemaService: Service instance\n    \"\"\"\n    return SchemaService()","size_bytes":18083},"attached_assets/BenchChatAI/ai_assistant/__init__.py":{"content":"__version__ = '0.0.1'\n","size_bytes":22},"ai_assistant/ai_assistant/doctype/ai_assistant_settings/__init__.py":{"content":"","size_bytes":0},"ai_assistant/ai_assistant/doctype/ai_assistant_settings/ai_assistant_settings.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe.model.document import Document\n\n\nclass AIAssistantSettings(Document):\n\tdef validate(self):\n\t\t\"\"\"Validate AI Assistant Settings\"\"\"\n\t\tif not self.ollama_url:\n\t\t\tfrappe.throw(\"Ollama URL is required\")\n\t\t\n\t\tif not self.model:\n\t\t\tfrappe.throw(\"AI Model is required\")\n\t\t\t\n\t\t# Ensure URL format is correct\n\t\tif not self.ollama_url.startswith(('http://', 'https://')):\n\t\t\tself.ollama_url = f\"http://{self.ollama_url}\"","size_bytes":533},"ai_assistant/ai_assistant/doctype/ai_assistant_settings/test_ai_assistant_settings.py":{"content":"# Copyright (c) 2025, ERPNext and Contributors\n# See license.txt\n\nimport frappe\nimport unittest\n\n\nclass TestAIAssistantSettings(unittest.TestCase):\n\tdef test_validate_required_fields(self):\n\t\t\"\"\"Test that required fields are validated\"\"\"\n\t\tsettings = frappe.new_doc(\"AI Assistant Settings\")\n\t\t\n\t\t# Test validation for required fields\n\t\twith self.assertRaises(frappe.exceptions.ValidationError):\n\t\t\tsettings.insert()\n\t\t\t\n\tdef test_url_format_correction(self):\n\t\t\"\"\"Test that URL format is corrected automatically\"\"\"\n\t\tsettings = frappe.new_doc(\"AI Assistant Settings\")\n\t\tsettings.ollama_url = \"localhost:11434\"\n\t\tsettings.model = \"llama2\"\n\t\tsettings.validate()\n\t\t\n\t\tself.assertTrue(settings.ollama_url.startswith(\"http://\"))","size_bytes":723},"ai_assistant/ai_assistant/doctype/ai_chat_message/__init__.py":{"content":"","size_bytes":0},"ai_assistant/ai_assistant/doctype/ai_chat_message/ai_chat_message.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe.model.document import Document\nfrom frappe.utils import now_datetime\n\n\nclass AIChatMessage(Document):\n\tdef before_insert(self):\n\t\t\"\"\"Set default values before inserting\"\"\"\n\t\tif not self.timestamp:\n\t\t\tself.timestamp = now_datetime()\n\t\t\t\n\t\tif not self.user:\n\t\t\tself.user = frappe.session.user\n\t\t\t\n\t\t# Validate role\n\t\tif self.role not in [\"user\", \"assistant\"]:\n\t\t\tfrappe.throw(\"Role must be either 'user' or 'assistant'\")\n\t\n\tdef after_insert(self):\n\t\t\"\"\"Update session message count after inserting new message\"\"\"\n\t\tif self.session:\n\t\t\tsession_doc = frappe.get_doc(\"AI Chat Session\", self.session)\n\t\t\tsession_doc.update_message_count()\n\t\n\tdef on_trash(self):\n\t\t\"\"\"Update session message count after deleting message\"\"\"\n\t\tif self.session:\n\t\t\tsession_doc = frappe.get_doc(\"AI Chat Session\", self.session)\n\t\t\tsession_doc.update_message_count()","size_bytes":961},"ai_assistant/ai_assistant/doctype/ai_chat_message/test_ai_chat_message.py":{"content":"# Copyright (c) 2025, ERPNext and Contributors\n# See license.txt\n\nimport frappe\nimport unittest\n\n\nclass TestAIChatMessage(unittest.TestCase):\n\tdef test_message_creation(self):\n\t\t\"\"\"Test that chat message is created with proper defaults\"\"\"\n\t\t# First create a session\n\t\tsession = frappe.new_doc(\"AI Chat Session\")\n\t\tsession.title = \"Test Session\"\n\t\tsession.user = \"Administrator\"\n\t\tsession.insert()\n\t\t\n\t\t# Create a message\n\t\tmessage = frappe.new_doc(\"AI Chat Message\")\n\t\tmessage.session = session.name\n\t\tmessage.content = \"Test message\"\n\t\tmessage.role = \"user\"\n\t\tmessage.insert()\n\t\t\n\t\tself.assertIsNotNone(message.timestamp)\n\t\tself.assertEqual(message.user, \"Administrator\")\n\t\t\n\t\t# Clean up\n\t\tmessage.delete()\n\t\tsession.delete()\n\t\t\n\tdef test_role_validation(self):\n\t\t\"\"\"Test that role validation works correctly\"\"\"\n\t\tmessage = frappe.new_doc(\"AI Chat Message\")\n\t\tmessage.content = \"Test message\"\n\t\tmessage.role = \"invalid_role\"\n\t\t\n\t\twith self.assertRaises(frappe.exceptions.ValidationError):\n\t\t\tmessage.insert()","size_bytes":1009},"ai_assistant/ai_assistant/doctype/ai_chat_session/__init__.py":{"content":"","size_bytes":0},"ai_assistant/ai_assistant/doctype/ai_chat_session/ai_chat_session.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe.model.document import Document\nfrom frappe.utils import now_datetime\n\n\nclass AIChatSession(Document):\n\tdef before_insert(self):\n\t\t\"\"\"Set session start time before inserting\"\"\"\n\t\tif not self.session_start:\n\t\t\tself.session_start = now_datetime()\n\t\t\t\n\t\tif not self.user:\n\t\t\tself.user = frappe.session.user\n\t\t\t\n\t\tif not self.title:\n\t\t\tself.title = f\"Chat Session - {frappe.format(self.session_start, 'datetime')}\"\n\t\n\tdef on_update(self):\n\t\t\"\"\"Update message count when session is updated\"\"\"\n\t\tself.update_message_count()\n\t\n\tdef update_message_count(self):\n\t\t\"\"\"Update the message count for this session\"\"\"\n\t\tmessage_count = frappe.db.count(\"AI Chat Message\", {\"session\": self.name})\n\t\tif message_count != self.message_count:\n\t\t\tfrappe.db.set_value(\"AI Chat Session\", self.name, \"message_count\", message_count)\n\t\n\tdef end_session(self):\n\t\t\"\"\"End the current session\"\"\"\n\t\tself.session_end = now_datetime()\n\t\tself.status = \"Completed\"\n\t\tself.save()","size_bytes":1065},"ai_assistant/ai_assistant/doctype/ai_chat_session/test_ai_chat_session.py":{"content":"# Copyright (c) 2025, ERPNext and Contributors\n# See license.txt\n\nimport frappe\nimport unittest\nfrom frappe.utils import now_datetime\n\n\nclass TestAIChatSession(unittest.TestCase):\n\tdef test_session_creation(self):\n\t\t\"\"\"Test that chat session is created with proper defaults\"\"\"\n\t\tsession = frappe.new_doc(\"AI Chat Session\")\n\t\tsession.title = \"Test Session\"\n\t\tsession.user = \"Administrator\"\n\t\tsession.insert()\n\t\t\n\t\tself.assertIsNotNone(session.session_start)\n\t\tself.assertEqual(session.status, \"Active\")\n\t\tself.assertEqual(session.message_count, 0)\n\t\t\n\t\t# Clean up\n\t\tsession.delete()\n\t\t\n\tdef test_message_count_update(self):\n\t\t\"\"\"Test that message count is updated correctly\"\"\"\n\t\tsession = frappe.new_doc(\"AI Chat Session\")\n\t\tsession.title = \"Test Session\"\n\t\tsession.user = \"Administrator\"\n\t\tsession.insert()\n\t\t\n\t\t# Create a message\n\t\tmessage = frappe.new_doc(\"AI Chat Message\")\n\t\tmessage.session = session.name\n\t\tmessage.content = \"Test message\"\n\t\tmessage.role = \"user\"\n\t\tmessage.user = \"Administrator\"\n\t\tmessage.insert()\n\t\t\n\t\t# Check if session message count is updated\n\t\tsession.reload()\n\t\tself.assertEqual(session.message_count, 1)\n\t\t\n\t\t# Clean up\n\t\tmessage.delete()\n\t\tsession.delete()","size_bytes":1187},"ai_assistant/ai_assistant/page/ai_assistant/__init__.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt","size_bytes":96},"ai_assistant/ai_assistant/page/ai_assistant/ai_assistant.css":{"content":"/* AI Assistant Page Styles */\n/* Using ERPNext design system variables and patterns */\n\n.ai-assistant-page {\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    background-color: var(--bg-color);\n}\n\n.ai-assistant-page .page-head {\n    background: var(--navbar-bg);\n    border-bottom: 1px solid var(--border-color);\n    padding: 15px 0;\n    flex-shrink: 0;\n}\n\n.ai-assistant-page .page-head .page-title h1 {\n    margin: 0;\n    color: var(--text-color);\n    font-size: 24px;\n    font-weight: 600;\n}\n\n.ai-assistant-page .page-head .page-title p {\n    margin: 5px 0 0 0;\n    color: var(--text-muted);\n    font-size: 14px;\n}\n\n.ai-assistant-page .page-actions {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n}\n\n.ai-assistant-page .page-body {\n    flex: 1;\n    padding: 20px 0;\n    overflow: hidden;\n}\n\n/* Chat Container */\n.chat-container {\n    height: calc(100vh - 160px);\n    display: flex;\n    flex-direction: column;\n    background: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    box-shadow: var(--shadow-sm);\n}\n\n.chat-header {\n    padding: 15px 20px;\n    border-bottom: 1px solid var(--border-color);\n    background: var(--control-bg);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-shrink: 0;\n}\n\n.session-info .session-title {\n    font-weight: 600;\n    color: var(--text-color);\n    font-size: 16px;\n}\n\n.session-info .session-status {\n    display: flex;\n    align-items: center;\n    gap: 5px;\n    margin-top: 4px;\n    font-size: 12px;\n    color: var(--text-muted);\n}\n\n/* Messages Area */\n.chat-messages {\n    flex: 1;\n    overflow-y: auto;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    scroll-behavior: smooth;\n}\n\n.chat-messages::-webkit-scrollbar {\n    width: 6px;\n}\n\n.chat-messages::-webkit-scrollbar-track {\n    background: var(--scrollbar-track-color);\n}\n\n.chat-messages::-webkit-scrollbar-thumb {\n    background: var(--scrollbar-thumb-color);\n    border-radius: 3px;\n}\n\n/* Welcome Message */\n.welcome-message {\n    display: flex;\n    gap: 12px;\n    padding: 20px;\n    background: linear-gradient(135deg, var(--primary-color-light), var(--primary-color));\n    border-radius: var(--border-radius-md);\n    color: white;\n    margin-bottom: 20px;\n}\n\n.welcome-message .assistant-avatar {\n    width: 40px;\n    height: 40px;\n    background: rgba(255, 255, 255, 0.2);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n}\n\n.welcome-message .message-content h4 {\n    margin: 0 0 8px 0;\n    font-size: 18px;\n    font-weight: 600;\n}\n\n.welcome-message .message-content p {\n    margin: 0;\n    opacity: 0.9;\n    line-height: 1.5;\n}\n\n/* Chat Messages */\n.message {\n    display: flex;\n    gap: 12px;\n    margin-bottom: 16px;\n    animation: fadeInUp 0.3s ease;\n}\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.message.user-message {\n    flex-direction: row-reverse;\n}\n\n.user-avatar, .assistant-avatar {\n    width: 36px;\n    height: 36px;\n    border-radius: 50%;\n    flex-shrink: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.user-avatar img {\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    object-fit: cover;\n}\n\n.assistant-avatar {\n    background: var(--primary-color);\n    color: white;\n}\n\n.message-content {\n    max-width: 70%;\n    position: relative;\n}\n\n.message-text {\n    background: var(--control-bg);\n    padding: 12px 16px;\n    border-radius: var(--border-radius-md);\n    line-height: 1.5;\n    word-wrap: break-word;\n}\n\n.user-message .message-text {\n    background: var(--primary-color);\n    color: white;\n    border-bottom-right-radius: 4px;\n}\n\n.assistant-message .message-text {\n    border-bottom-left-radius: 4px;\n}\n\n.message-text pre {\n    background: var(--bg-color);\n    padding: 12px;\n    border-radius: var(--border-radius);\n    margin: 8px 0;\n    overflow-x: auto;\n    font-size: 13px;\n}\n\n.message-text code {\n    background: var(--bg-color);\n    padding: 2px 6px;\n    border-radius: 3px;\n    font-size: 13px;\n}\n\n.message-time {\n    font-size: 11px;\n    color: var(--text-muted);\n    margin-top: 4px;\n    text-align: right;\n}\n\n.user-message .message-time {\n    text-align: left;\n}\n\n.error-message .message-text {\n    background: var(--red-100);\n    border-left: 3px solid var(--red-500);\n    color: var(--red-700);\n}\n\n/* Typing Indicator */\n.typing-indicator {\n    display: flex;\n    gap: 12px;\n    margin-bottom: 16px;\n}\n\n.typing-dots {\n    background: var(--control-bg);\n    padding: 12px 16px;\n    border-radius: var(--border-radius-md);\n    border-bottom-left-radius: 4px;\n    display: flex;\n    gap: 4px;\n    align-items: center;\n}\n\n.typing-dots span {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: var(--text-muted);\n    animation: typing 1.4s infinite ease-in-out;\n}\n\n.typing-dots span:nth-child(2) {\n    animation-delay: 0.2s;\n}\n\n.typing-dots span:nth-child(3) {\n    animation-delay: 0.4s;\n}\n\n@keyframes typing {\n    0%, 80%, 100% {\n        opacity: 0.3;\n        transform: scale(0.8);\n    }\n    40% {\n        opacity: 1;\n        transform: scale(1);\n    }\n}\n\n/* Chat Input */\n.chat-input-container {\n    padding: 20px;\n    border-top: 1px solid var(--border-color);\n    background: var(--control-bg);\n    flex-shrink: 0;\n}\n\n.chat-input-container .input-group {\n    position: relative;\n}\n\n.chat-input-container textarea {\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-md);\n    padding: 12px 16px;\n    resize: none;\n    font-family: var(--font-family);\n    line-height: 1.4;\n    max-height: 120px;\n    min-height: 44px;\n}\n\n.chat-input-container textarea:focus {\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 2px var(--primary-color-light);\n}\n\n.chat-input-container .input-group-btn {\n    position: absolute;\n    right: 8px;\n    bottom: 8px;\n}\n\n.chat-input-container .input-group-btn .btn {\n    border-radius: 50%;\n    width: 36px;\n    height: 36px;\n    padding: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.input-footer {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-top: 8px;\n    font-size: 12px;\n}\n\n.char-count {\n    color: var(--text-muted);\n}\n\n.char-count.text-warning {\n    color: var(--orange-500);\n}\n\n.char-count.text-danger {\n    color: var(--red-500);\n}\n\n/* Sidebar */\n.sidebar {\n    height: calc(100vh - 160px);\n    overflow-y: auto;\n    padding-left: 20px;\n}\n\n.sidebar-section {\n    margin-bottom: 30px;\n}\n\n.sidebar-section h5 {\n    margin: 0 0 15px 0;\n    font-size: 14px;\n    font-weight: 600;\n    color: var(--text-color);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n/* Session List */\n.session-list {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n.session-item {\n    padding: 12px 16px;\n    background: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.session-item:hover {\n    background: var(--control-bg);\n    border-color: var(--primary-color-light);\n}\n\n.session-item.active {\n    background: var(--primary-color-light);\n    border-color: var(--primary-color);\n    color: var(--primary-color-dark);\n}\n\n.session-item .session-title {\n    font-weight: 500;\n    font-size: 13px;\n    margin-bottom: 4px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.session-item .session-meta {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    font-size: 11px;\n}\n\n.no-sessions {\n    padding: 30px 15px;\n    text-align: center;\n    color: var(--text-muted);\n    font-style: italic;\n}\n\n/* Quick Actions */\n.quick-actions {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n.quick-action {\n    text-align: left;\n    padding: 8px 12px;\n    font-size: 13px;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    border: 1px solid var(--border-color);\n    transition: all 0.2s ease;\n}\n\n.quick-action:hover {\n    background: var(--control-bg);\n    border-color: var(--primary-color-light);\n}\n\n.quick-action i {\n    width: 16px;\n    text-align: center;\n    opacity: 0.7;\n}\n\n/* Status Panel */\n.status-panel {\n    background: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    padding: 16px;\n}\n\n.status-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 6px 0;\n    font-size: 13px;\n}\n\n.status-item:not(:last-child) {\n    border-bottom: 1px solid var(--border-color);\n}\n\n.status-item label {\n    color: var(--text-muted);\n    font-weight: 500;\n    margin: 0;\n}\n\n.status-value {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-weight: 500;\n}\n\n/* Modal Customizations */\n.modal-content {\n    border-radius: var(--border-radius-lg);\n    box-shadow: var(--shadow-lg);\n}\n\n.modal-header {\n    border-bottom: 1px solid var(--border-color);\n    background: var(--control-bg);\n}\n\n.modal-title {\n    font-weight: 600;\n    color: var(--text-color);\n}\n\n.command-preview {\n    background: var(--bg-color);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    padding: 12px;\n    font-size: 13px;\n    max-height: 200px;\n    overflow-y: auto;\n    word-wrap: break-word;\n}\n\n.command-description {\n    color: var(--text-color);\n    font-weight: 500;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .ai-assistant-page .page-head .row {\n        flex-direction: column;\n        gap: 15px;\n    }\n    \n    .ai-assistant-page .page-actions {\n        justify-content: center;\n    }\n    \n    .chat-container {\n        height: calc(100vh - 200px);\n    }\n    \n    .sidebar {\n        height: auto;\n        margin-top: 20px;\n        padding-left: 0;\n    }\n    \n    .message-content {\n        max-width: 85%;\n    }\n    \n    .chat-input-container {\n        padding: 15px;\n    }\n}\n\n@media (max-width: 576px) {\n    .ai-assistant-page .page-head {\n        padding: 10px 0;\n    }\n    \n    .chat-messages {\n        padding: 15px;\n        gap: 12px;\n    }\n    \n    .message-content {\n        max-width: 90%;\n    }\n    \n    .welcome-message {\n        padding: 15px;\n        margin-bottom: 15px;\n    }\n    \n    .sidebar-section {\n        margin-bottom: 20px;\n    }\n}\n\n/* Indicators */\n.indicator {\n    display: inline-block;\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: var(--gray-500);\n}\n\n.indicator.green {\n    background: var(--green-500);\n}\n\n.indicator.red {\n    background: var(--red-500);\n}\n\n.indicator.orange {\n    background: var(--orange-500);\n}\n\n.indicator.grey {\n    background: var(--gray-400);\n}\n\n/* Loading states */\n.loading {\n    opacity: 0.6;\n    pointer-events: none;\n}\n\n.loading::after {\n    content: \"\";\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 20px;\n    height: 20px;\n    margin: -10px 0 0 -10px;\n    border: 2px solid var(--border-color);\n    border-top: 2px solid var(--primary-color);\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}","size_bytes":11347},"ai_assistant/ai_assistant/page/ai_assistant/ai_assistant.js":{"content":"// Copyright (c) 2025, ERPNext and contributors\n// For license information, please see license.txt\n\nfrappe.pages['ai_assistant'].on_page_load = function(wrapper) {\n    var page = frappe.ui.make_app_page({\n        parent: wrapper,\n        title: __('AI Assistant'),\n        single_column: true\n    });\n\n    // Initialize the AI Assistant interface\n    new AIAssistantInterface(page);\n};\n\nclass AIAssistantInterface {\n    constructor(page) {\n        this.page = page;\n        this.wrapper = page.wrapper;\n        this.current_session_id = null;\n        this.user_data = null;\n        this.settings = {};\n        this.permissions = {};\n        this.pending_command = null;\n        \n        this.setup_page();\n        this.init_realtime();\n        this.load_initial_data();\n    }\n\n    setup_page() {\n        // Set up the main page layout\n        $(this.wrapper).find('.layout-main-section').html(frappe.render_template('ai_assistant', {}));\n        \n        this.setup_elements();\n        this.setup_event_handlers();\n        this.setup_auto_resize();\n    }\n\n    setup_elements() {\n        // Cache frequently used elements\n        this.$chat_messages = $('#chat-messages');\n        this.$chat_input = $('#chat-input');\n        this.$send_button = $('#send-button');\n        this.$session_list = $('#session-list');\n        this.$typing_indicator = $('#typing-indicator');\n        this.$char_count = $('#char-count');\n    }\n\n    setup_event_handlers() {\n        const self = this;\n\n        // Chat input handlers\n        this.$chat_input.on('input', () => this.handle_input_change());\n        this.$chat_input.on('keydown', (e) => this.handle_keydown(e));\n\n        // Button handlers\n        this.$send_button.on('click', () => this.send_message());\n        $('#new-session').on('click', () => this.create_new_session());\n        $('#clear-history').on('click', () => this.confirm_clear_history());\n        $('#toggle-settings').on('click', () => this.show_settings_modal());\n\n        // Settings modal handlers\n        $('#save-settings').on('click', () => this.save_settings());\n        $('#provider').on('change', (e) => this.toggle_provider_sections(e.target.value));\n\n        // Command confirmation handlers\n        $('#confirm-command').on('click', () => this.execute_confirmed_command());\n\n        // Quick action handlers\n        $('.quick-action').on('click', function() {\n            const query = $(this).data('query');\n            self.$chat_input.val(query);\n            self.handle_input_change();\n            self.send_message();\n        });\n\n        // Session list handlers\n        this.$session_list.on('click', '.session-item', function() {\n            const sessionId = $(this).data('session-id');\n            self.load_session(sessionId);\n        });\n    }\n\n    setup_auto_resize() {\n        // Auto-resize textarea\n        this.$chat_input.on('input', function() {\n            this.style.height = 'auto';\n            this.style.height = Math.min(this.scrollHeight, 120) + 'px';\n        });\n    }\n\n    init_realtime() {\n        // Set up realtime updates for chat messages\n        if (frappe.realtime) {\n            frappe.realtime.on('ai_assistant_message', (data) => {\n                if (data.session_id === this.current_session_id) {\n                    this.handle_realtime_message(data);\n                }\n            });\n\n            frappe.realtime.on('ai_assistant_status', (data) => {\n                this.update_status_panel(data);\n            });\n        }\n    }\n\n    load_initial_data() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.page.ai_assistant.ai_assistant.get_page_data',\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.user_data = r.message.user;\n                    this.settings = r.message.settings;\n                    this.permissions = r.message.permissions;\n                    this.update_ui();\n                    this.load_recent_sessions();\n                    this.check_ai_status();\n                } else {\n                    frappe.msgprint(__('Failed to load page data'));\n                }\n            },\n            error: () => {\n                frappe.msgprint(__('Error loading AI Assistant'));\n            }\n        });\n    }\n\n    update_ui() {\n        // Update status panel with current model based on provider\n        const currentModel = this.settings.provider === 'openai' \n            ? this.settings.openai_model || 'gpt-5'\n            : this.settings.ollama_model || 'llama2';\n        $('#current-model').text(currentModel);\n        \n        $('#safe-mode-status').html(\n            this.settings.safe_mode ? \n            '<i class=\"indicator green\"></i> Enabled' : \n            '<i class=\"indicator red\"></i> Disabled'\n        );\n\n        // Hide settings button if no permission\n        if (!this.permissions.can_manage_settings) {\n            $('#toggle-settings').hide();\n        }\n\n        // Disable input if no permission to send messages\n        if (!this.permissions.can_send_messages) {\n            this.$chat_input.prop('disabled', true);\n            this.$send_button.prop('disabled', true);\n        }\n    }\n\n    handle_input_change() {\n        const text = this.$chat_input.val().trim();\n        const charCount = text.length;\n        \n        this.$char_count.text(`${charCount}/2000`);\n        this.$send_button.prop('disabled', !text || charCount > 2000);\n        \n        if (charCount > 1900) {\n            this.$char_count.addClass('text-warning');\n        } else if (charCount > 2000) {\n            this.$char_count.addClass('text-danger');\n        } else {\n            this.$char_count.removeClass('text-warning text-danger');\n        }\n    }\n\n    handle_keydown(e) {\n        if (e.key === 'Enter') {\n            if (e.shiftKey) {\n                // Allow new line with Shift+Enter\n                return true;\n            } else {\n                // Send message with Enter\n                e.preventDefault();\n                if (!this.$send_button.prop('disabled')) {\n                    this.send_message();\n                }\n            }\n        }\n    }\n\n    send_message() {\n        const message = this.$chat_input.val().trim();\n        if (!message) return;\n\n        // Clear input and disable button\n        this.$chat_input.val('').trigger('input');\n        this.handle_input_change();\n\n        // Add user message to chat\n        this.add_message('user', message);\n\n        // Show typing indicator\n        this.show_typing_indicator();\n\n        // Send to backend\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.send_message',\n            args: {\n                session_id: this.current_session_id,\n                message: message,\n                role: 'user'\n            },\n            callback: (r) => {\n                this.hide_typing_indicator();\n                \n                if (r.message && r.message.success) {\n                    this.current_session_id = r.message.session_id;\n                    \n                    // Add AI response\n                    this.add_message('assistant', r.message.ai_response);\n\n                    // Handle command analysis\n                    if (r.message.command_analysis && r.message.command_analysis.command) {\n                        this.handle_command_analysis(r.message.command_analysis, r.message.assistant_message_id);\n                    }\n\n                    // Update session title if needed\n                    this.update_session_title();\n                } else {\n                    this.add_message('assistant', r.message?.error || __('Sorry, I encountered an error processing your request.'), true);\n                }\n            },\n            error: () => {\n                this.hide_typing_indicator();\n                this.add_message('assistant', __('Connection error. Please try again.'), true);\n            }\n        });\n    }\n\n    add_message(role, content, is_error = false) {\n        const messageClass = role === 'user' ? 'user-message' : 'assistant-message';\n        const errorClass = is_error ? 'error-message' : '';\n        \n        const avatar = role === 'user' ? \n            `<img src=\"${this.user_data?.image || '/assets/frappe/images/default-avatar.png'}\" class=\"user-avatar\">` :\n            '<div class=\"assistant-avatar\"><i class=\"fa fa-robot\"></i></div>';\n\n        const messageHtml = `\n            <div class=\"message ${messageClass} ${errorClass}\">\n                ${avatar}\n                <div class=\"message-content\">\n                    <div class=\"message-text\">${this.format_message_content(content)}</div>\n                    <div class=\"message-time\">${moment().format('HH:mm')}</div>\n                </div>\n            </div>\n        `;\n\n        this.$chat_messages.append(messageHtml);\n        this.scroll_to_bottom();\n    }\n\n    format_message_content(content) {\n        // Basic formatting for message content\n        return content\n            .replace(/\\n/g, '<br>')\n            .replace(/```(\\w+)?\\n?([\\s\\S]*?)```/g, '<pre><code>$2</code></pre>')\n            .replace(/`([^`]+)`/g, '<code>$1</code>');\n    }\n\n    show_typing_indicator() {\n        this.$typing_indicator.show();\n        this.scroll_to_bottom();\n    }\n\n    hide_typing_indicator() {\n        this.$typing_indicator.hide();\n    }\n\n    scroll_to_bottom() {\n        const chatContainer = this.$chat_messages[0];\n        chatContainer.scrollTop = chatContainer.scrollHeight;\n    }\n\n    handle_command_analysis(analysis, message_id) {\n        if (analysis.isDestructive && this.settings.confirm_destructive) {\n            // Show confirmation modal for destructive commands\n            this.pending_command = {\n                command: analysis.command,\n                description: analysis.description,\n                message_id: message_id\n            };\n            this.show_command_confirmation_modal(analysis);\n        } else if (analysis.command && analysis.category !== 'other') {\n            // Auto-execute non-destructive commands\n            this.execute_command(analysis.command, message_id);\n        }\n    }\n\n    show_command_confirmation_modal(analysis) {\n        $('#command-preview').text(analysis.command);\n        $('#command-description').text(analysis.description);\n        $('#command-modal').modal('show');\n    }\n\n    execute_confirmed_command() {\n        if (this.pending_command) {\n            $('#command-modal').modal('hide');\n            this.execute_command(this.pending_command.command, this.pending_command.message_id);\n            this.pending_command = null;\n        }\n    }\n\n    execute_command(command, message_id) {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.confirm_execute',\n            args: {\n                message_id: message_id,\n                command: command\n            },\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.add_message('assistant', \n                        `Command executed successfully:\\n\\`\\`\\`\\n${JSON.stringify(r.message.result, null, 2)}\\n\\`\\`\\``);\n                } else {\n                    this.add_message('assistant', \n                        `Command execution failed: ${r.message?.error || 'Unknown error'}`, true);\n                }\n            }\n        });\n    }\n\n    create_new_session() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.page.ai_assistant.ai_assistant.initialize_session',\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.current_session_id = r.message.session.id;\n                    this.$chat_messages.find('.message').remove();\n                    this.show_welcome_message();\n                    this.load_recent_sessions();\n                    frappe.show_alert({message: __('New session created'), indicator: 'green'});\n                } else {\n                    frappe.msgprint(__('Failed to create new session'));\n                }\n            }\n        });\n    }\n\n    show_welcome_message() {\n        // The welcome message is already in the HTML template\n        $('.welcome-message').show();\n    }\n\n    confirm_clear_history() {\n        frappe.confirm(\n            __('Are you sure you want to clear all chat history? This action cannot be undone.'),\n            () => {\n                this.clear_history();\n            }\n        );\n    }\n\n    clear_history() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.clear_history',\n            args: {\n                session_id: this.current_session_id\n            },\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.$chat_messages.find('.message').remove();\n                    this.show_welcome_message();\n                    this.current_session_id = null;\n                    this.load_recent_sessions();\n                    frappe.show_alert({message: __('History cleared'), indicator: 'green'});\n                } else {\n                    frappe.msgprint(__('Failed to clear history'));\n                }\n            }\n        });\n    }\n\n    show_settings_modal() {\n        // Populate current settings\n        $('#provider').val(this.settings.provider || 'ollama');\n        $('#ollama-url').val(this.settings.ollama_url);\n        $('#ollama-model').val(this.settings.ollama_model);\n        // Don't populate API key for security - leave blank for new input\n        $('#openai-api-key').val('');\n        if (this.settings.has_openai_key) {\n            $('#openai-api-key').attr('placeholder', 'API key is configured (enter new key to change)');\n        }\n        $('#openai-model').val(this.settings.openai_model);\n        $('#safe-mode').prop('checked', this.settings.safe_mode);\n        $('#confirm-destructive').prop('checked', this.settings.confirm_destructive);\n        $('#log-commands').prop('checked', this.settings.log_commands);\n        \n        // Show/hide relevant sections based on provider\n        this.toggle_provider_sections(this.settings.provider || 'ollama');\n        \n        $('#settings-modal').modal('show');\n    }\n\n    save_settings() {\n        const settings = {\n            provider: $('#provider').val(),\n            ollama_url: $('#ollama-url').val(),\n            ollama_model: $('#ollama-model').val(),\n            openai_model: $('#openai-model').val(),\n            safe_mode: $('#safe-mode').prop('checked'),\n            confirm_destructive: $('#confirm-destructive').prop('checked'),\n            log_commands: $('#log-commands').prop('checked')\n        };\n        \n        // Only include API key if it's not empty (to avoid overwriting with blank)\n        const apiKey = $('#openai-api-key').val().trim();\n        if (apiKey) {\n            settings.openai_api_key = apiKey;\n        }\n\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.update_settings',\n            args: settings,\n            callback: (r) => {\n                if (r.message) {\n                    this.settings = r.message;\n                    this.update_ui();\n                    $('#settings-modal').modal('hide');\n                    frappe.show_alert({message: __('Settings saved'), indicator: 'green'});\n                    this.check_ai_status();\n                } else {\n                    frappe.msgprint(__('Failed to save settings'));\n                }\n            }\n        });\n    }\n\n    toggle_provider_sections(provider) {\n        if (provider === 'openai') {\n            $('.ollama-section').hide();\n            $('.openai-section').show();\n        } else {\n            $('.ollama-section').show();\n            $('.openai-section').hide();\n        }\n    }\n\n    load_recent_sessions() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.get_chat_sessions',\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.render_session_list(r.message.sessions);\n                }\n            }\n        });\n    }\n\n    render_session_list(sessions) {\n        if (!sessions || sessions.length === 0) {\n            this.$session_list.html('<div class=\"no-sessions text-muted text-center\"><p>' + __('No recent sessions') + '</p></div>');\n            return;\n        }\n\n        let html = '';\n        sessions.forEach(session => {\n            const isActive = session.name === this.current_session_id ? 'active' : '';\n            const statusIcon = session.status === 'Active' ? 'green' : 'grey';\n            \n            html += `\n                <div class=\"session-item ${isActive}\" data-session-id=\"${session.name}\">\n                    <div class=\"session-title\">${session.title}</div>\n                    <div class=\"session-meta\">\n                        <small class=\"text-muted\">${moment(session.session_start).fromNow()}</small>\n                        <span class=\"indicator ${statusIcon}\"></span>\n                    </div>\n                </div>\n            `;\n        });\n\n        this.$session_list.html(html);\n    }\n\n    load_session(session_id) {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.get_chat_messages',\n            args: {\n                session_id: session_id\n            },\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.current_session_id = session_id;\n                    this.render_chat_messages(r.message.messages);\n                    this.update_session_title();\n                } else {\n                    frappe.msgprint(__('Failed to load session'));\n                }\n            }\n        });\n    }\n\n    render_chat_messages(messages) {\n        this.$chat_messages.find('.message').remove();\n        \n        if (!messages || messages.length === 0) {\n            this.show_welcome_message();\n            return;\n        }\n\n        messages.forEach(message => {\n            this.add_message(message.role, message.content, message.is_error);\n        });\n    }\n\n    update_session_title() {\n        if (this.current_session_id) {\n            const sessionItem = $(`.session-item[data-session-id=\"${this.current_session_id}\"]`);\n            if (sessionItem.length) {\n                const title = sessionItem.find('.session-title').text();\n                $('#current-session-title').text(title);\n                $('.session-item').removeClass('active');\n                sessionItem.addClass('active');\n            }\n        }\n    }\n\n    check_ai_status() {\n        // Simple status check - in a real implementation, you might have a dedicated endpoint\n        $('#ai-status').html('<i class=\"indicator orange\"></i> ' + __('Checking...'));\n        \n        // Simulate status check\n        setTimeout(() => {\n            $('#ai-status').html('<i class=\"indicator green\"></i> ' + __('Connected'));\n        }, 1000);\n    }\n\n    handle_realtime_message(data) {\n        // Handle real-time message updates\n        if (data.type === 'message') {\n            this.add_message(data.role, data.content);\n        } else if (data.type === 'typing') {\n            if (data.typing) {\n                this.show_typing_indicator();\n            } else {\n                this.hide_typing_indicator();\n            }\n        }\n    }\n\n    update_status_panel(data) {\n        // Update status panel with real-time data\n        if (data.ai_status) {\n            $('#ai-status').html(`<i class=\"indicator ${data.ai_status.connected ? 'green' : 'red'}\"></i> ${data.ai_status.status}`);\n        }\n    }\n}","size_bytes":19528},"ai_assistant/ai_assistant/page/ai_assistant/ai_assistant.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe import _\nfrom frappe.utils import now_datetime\n\n\nclass AIAssistantPage:\n    \"\"\"\n    Server-side page controller for AI Assistant Desk page.\n    \n    Handles page configuration, permissions, and initialization.\n    \"\"\"\n    \n    def __init__(self):\n        self.page_name = \"ai_assistant\"\n        self.page_title = _(\"AI Assistant\")\n        self.icon = \"fa fa-robot\"\n        \n    def get_context(self):\n        \"\"\"\n        Get page context and configuration.\n        \n        Returns:\n            dict: Page context with configuration and initial data\n        \"\"\"\n        # Check permissions\n        self.check_permission()\n        \n        context = frappe._dict()\n        context.page_title = self.page_title\n        context.icon = self.icon\n        context.user = frappe.session.user\n        context.user_image = frappe.db.get_value(\"User\", frappe.session.user, \"user_image\")\n        context.full_name = frappe.utils.get_fullname(frappe.session.user)\n        \n        # Get current settings\n        try:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            context.settings = {\n                \"ollama_url\": settings.ollama_url or \"http://localhost:11434\",\n                \"model\": settings.model or \"llama2\",\n                \"safe_mode\": settings.safe_mode,\n                \"confirm_destructive\": settings.confirm_destructive,\n                \"log_commands\": settings.log_commands\n            }\n        except Exception:\n            # Provide defaults if settings not found\n            context.settings = {\n                \"ollama_url\": \"http://localhost:11434\",\n                \"model\": \"llama2\", \n                \"safe_mode\": 1,\n                \"confirm_destructive\": 1,\n                \"log_commands\": 0\n            }\n        \n        # Get recent chat sessions for the user\n        try:\n            context.recent_sessions = frappe.get_all(\"AI Chat Session\",\n                filters={\"user\": frappe.session.user, \"status\": \"Active\"},\n                fields=[\"name\", \"title\", \"session_start\", \"message_count\"],\n                order_by=\"session_start desc\",\n                limit=10\n            )\n        except Exception:\n            context.recent_sessions = []\n        \n        # Check user permissions\n        context.can_manage_settings = frappe.has_permission(\"AI Assistant Settings\", \"write\")\n        context.can_create_sessions = frappe.has_permission(\"AI Chat Session\", \"create\")\n        context.can_send_messages = frappe.has_permission(\"AI Chat Message\", \"create\")\n        \n        return context\n    \n    def check_permission(self):\n        \"\"\"\n        Check if user has permission to access the AI Assistant page.\n        \n        Raises:\n            frappe.PermissionError: If user doesn't have required permissions\n        \"\"\"\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Please log in to access AI Assistant\"), frappe.AuthenticationError)\n        \n        # Check if user can at least read AI Chat Sessions or Messages\n        if not (frappe.has_permission(\"AI Chat Session\", \"read\") or \n                frappe.has_permission(\"AI Chat Message\", \"read\")):\n            frappe.throw(_(\"You don't have permission to access AI Assistant\"), \n                        frappe.PermissionError)\n    \n    @staticmethod\n    def get_page_info():\n        \"\"\"\n        Get static page information for registration.\n        \n        Returns:\n            dict: Page registration info\n        \"\"\"\n        return {\n            \"page_name\": \"ai_assistant\",\n            \"page_title\": _(\"AI Assistant\"),\n            \"icon\": \"fa fa-robot\",\n            \"single_page\": True,\n            \"is_query_report\": False\n        }\n\n\ndef get_context(context=None):\n    \"\"\"\n    ERPNext page context handler.\n    \n    Args:\n        context (dict, optional): Existing context\n        \n    Returns:\n        dict: Complete page context\n    \"\"\"\n    page = AIAssistantPage()\n    return page.get_context()\n\n\n@frappe.whitelist()\ndef get_page_data():\n    \"\"\"\n    Get page data for JavaScript initialization.\n    \n    Returns:\n        dict: Page data including user info and permissions\n    \"\"\"\n    try:\n        page = AIAssistantPage()\n        page.check_permission()\n        \n        # Get settings using the standardized get_settings function\n        from ai_assistant.ai_assistant.api import get_settings\n        try:\n            settings_data = get_settings()\n        except Exception:\n            settings_data = {\n                \"provider\": \"ollama\",\n                \"ollama_url\": \"http://localhost:11434\",\n                \"ollama_model\": \"llama2\",\n                \"has_openai_key\": False,\n                \"openai_model\": \"gpt-5\",\n                \"safe_mode\": 1,\n                \"confirm_destructive\": 1,\n                \"log_commands\": 0\n            }\n        \n        return {\n            \"success\": True,\n            \"user\": {\n                \"name\": frappe.session.user,\n                \"full_name\": frappe.utils.get_fullname(frappe.session.user),\n                \"image\": frappe.db.get_value(\"User\", frappe.session.user, \"user_image\")\n            },\n            \"settings\": settings_data,\n            \"permissions\": {\n                \"can_manage_settings\": frappe.has_permission(\"AI Assistant Settings\", \"write\"),\n                \"can_create_sessions\": frappe.has_permission(\"AI Chat Session\", \"create\"),\n                \"can_send_messages\": frappe.has_permission(\"AI Chat Message\", \"create\"),\n                \"can_execute_commands\": frappe.has_permission(\"AI Chat Message\", \"write\")\n            },\n            \"server_time\": now_datetime()\n        }\n        \n    except frappe.AuthenticationError:\n        frappe.throw(_(\"Authentication required\"))\n    except frappe.PermissionError:\n        frappe.throw(_(\"Access denied\"))\n    except Exception as e:\n        frappe.log_error(f\"Get Page Data Error: {str(e)}\", \"AI Assistant Page\")\n        frappe.throw(_(\"Failed to load page data\"))\n\n\n@frappe.whitelist()\ndef initialize_session():\n    \"\"\"\n    Initialize a new chat session for the current user.\n    \n    Returns:\n        dict: New session information\n    \"\"\"\n    try:\n        page = AIAssistantPage()\n        page.check_permission()\n        \n        if not frappe.has_permission(\"AI Chat Session\", \"create\"):\n            frappe.throw(_(\"Not permitted to create chat sessions\"), frappe.PermissionError)\n        \n        # Auto-scan database if enabled\n        from ai_assistant.ai_assistant.services.schema import SchemaService\n        try:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            if settings.auto_scan_database:\n                # Trigger database scan for new session context\n                schema_data = SchemaService.scan_database(include_custom=True, max_tables=500)\n                SchemaService.save_schema_to_settings(schema_data)\n                \n                frappe.logger(\"ai_assistant\").info(f\"Database scanned for new session. \"\n                                                 f\"Found {schema_data['summary']['total_doctypes']} DocTypes \"\n                                                 f\"and {schema_data['summary']['total_tables']} tables.\")\n        except Exception as scan_error:\n            frappe.log_error(f\"Database scan error during session init: {str(scan_error)}\", \"AI Assistant\")\n            # Continue with session creation even if scan fails\n\n        # Create new session\n        session_doc = frappe.get_doc({\n            \"doctype\": \"AI Chat Session\",\n            \"title\": f\"Chat Session - {frappe.format(now_datetime(), 'datetime')}\",\n            \"user\": frappe.session.user,\n            \"session_start\": now_datetime(),\n            \"status\": \"Active\",\n            \"message_count\": 0\n        })\n        session_doc.insert()\n        \n        # Get schema context for response\n        try:\n            schema_context = SchemaService.get_schema_context(format_type=\"summary\")\n        except Exception:\n            schema_context = \"Database context unavailable\"\n        \n        return {\n            \"success\": True,\n            \"session\": {\n                \"id\": session_doc.name,\n                \"title\": session_doc.title,\n                \"status\": session_doc.status,\n                \"session_start\": session_doc.session_start\n            },\n            \"database_context\": schema_context\n        }\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Initialize Session Error: {str(e)}\", \"AI Assistant Page\")\n        frappe.throw(_(\"Failed to create new session\"))","size_bytes":8659},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/__init__.py":{"content":"","size_bytes":0},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/api.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport frappe\nfrom frappe import _\nfrom frappe.utils import now_datetime, cint\nfrom ai_assistant.ai_assistant.services.ollama import OllamaService\nfrom ai_assistant.ai_assistant.services.erpnext_exec import ERPNextExecutor\nfrom ai_assistant.ai_assistant.services.schema import SchemaService\n\n\n@frappe.whitelist()\ndef send_message(session_id, message, role=\"user\"):\n    \"\"\"\n    Send a chat message and get AI response.\n    \n    Args:\n        session_id (str): Chat session ID\n        message (str): Message content\n        role (str): Message role ('user' or 'assistant')\n    \n    Returns:\n        dict: Response with message ID and AI response\n    \"\"\"\n    try:\n        # Check permissions\n        if not frappe.has_permission(\"AI Chat Message\", \"create\"):\n            frappe.throw(_(\"Not permitted to create chat messages\"), frappe.PermissionError)\n        \n        # Validate session\n        if session_id:\n            if not frappe.db.exists(\"AI Chat Session\", session_id):\n                frappe.throw(_(\"Chat session not found\"))\n            \n            # Check if user has access to this session\n            session_user = frappe.db.get_value(\"AI Chat Session\", session_id, \"user\")\n            if session_user != frappe.session.user and not frappe.has_permission(\"AI Chat Session\", \"read\"):\n                frappe.throw(_(\"Not permitted to access this chat session\"), frappe.PermissionError)\n        else:\n            # Create new session\n            session_doc = frappe.get_doc({\n                \"doctype\": \"AI Chat Session\",\n                \"title\": f\"Chat Session - {frappe.format(now_datetime(), 'datetime')}\",\n                \"user\": frappe.session.user,\n                \"session_start\": now_datetime(),\n                \"status\": \"Active\"\n            })\n            session_doc.insert()\n            session_id = session_doc.name\n        \n        # Create user message\n        user_msg = frappe.get_doc({\n            \"doctype\": \"AI Chat Message\",\n            \"session\": session_id,\n            \"role\": \"user\",\n            \"content\": message,\n            \"user\": frappe.session.user,\n            \"timestamp\": now_datetime()\n        })\n        user_msg.insert()\n        \n        # Generate AI response if role is user\n        if role == \"user\":\n            try:\n                # Get settings\n                settings = get_settings()\n                \n                # Get schema context for AI\n                schema_context = SchemaService.get_schema_context()\n                \n                # Generate AI response using Ollama\n                ollama = OllamaService(\n                    url=settings.get(\"ollama_url\", \"http://localhost:11434\"),\n                    model=settings.get(\"model\", \"llama2\")\n                )\n                \n                # Analyze if this is a command\n                command_analysis = ollama.analyze_command(message, schema_context)\n                \n                ai_response = ollama.generate_response(message, schema_context)\n                \n                # Create assistant message\n                assistant_msg = frappe.get_doc({\n                    \"doctype\": \"AI Chat Message\",\n                    \"session\": session_id,\n                    \"role\": \"assistant\",\n                    \"content\": ai_response,\n                    \"user\": frappe.session.user,\n                    \"timestamp\": now_datetime()\n                })\n                \n                # If command analysis indicates execution needed\n                if command_analysis and command_analysis.get(\"isDestructive\"):\n                    assistant_msg.command_executed = command_analysis.get(\"command\", \"\")\n                    \n                assistant_msg.insert()\n                \n                return {\n                    \"success\": True,\n                    \"user_message_id\": user_msg.name,\n                    \"assistant_message_id\": assistant_msg.name,\n                    \"session_id\": session_id,\n                    \"ai_response\": ai_response,\n                    \"command_analysis\": command_analysis\n                }\n                \n            except Exception as ai_error:\n                frappe.log_error(f\"AI Response Error: {str(ai_error)}\", \"AI Assistant\")\n                \n                # Create error response\n                error_msg = frappe.get_doc({\n                    \"doctype\": \"AI Chat Message\",\n                    \"session\": session_id,\n                    \"role\": \"assistant\",\n                    \"content\": f\"I encountered an error processing your request: {str(ai_error)}\",\n                    \"user\": frappe.session.user,\n                    \"timestamp\": now_datetime(),\n                    \"is_error\": 1\n                })\n                error_msg.insert()\n                \n                return {\n                    \"success\": False,\n                    \"user_message_id\": user_msg.name,\n                    \"assistant_message_id\": error_msg.name,\n                    \"session_id\": session_id,\n                    \"error\": str(ai_error)\n                }\n        \n        return {\n            \"success\": True,\n            \"message_id\": user_msg.name,\n            \"session_id\": session_id\n        }\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Send Message Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to send message: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef confirm_execute(message_id, command):\n    \"\"\"\n    Confirm and execute a command from AI assistant.\n    \n    Args:\n        message_id (str): AI Chat Message ID\n        command (str): Command to execute\n    \n    Returns:\n        dict: Execution result\n    \"\"\"\n    try:\n        # Check permissions\n        if not frappe.has_permission(\"AI Chat Message\", \"write\"):\n            frappe.throw(_(\"Not permitted to execute commands\"), frappe.PermissionError)\n        \n        # Get message\n        message = frappe.get_doc(\"AI Chat Message\", message_id)\n        \n        # Verify user has access\n        if message.user != frappe.session.user and not frappe.has_permission(\"AI Chat Message\", \"read\"):\n            frappe.throw(_(\"Not permitted to access this message\"), frappe.PermissionError)\n        \n        # Get settings\n        settings = get_settings()\n        \n        # Check if safe mode is enabled and user confirmed\n        if settings.get(\"safe_mode\") and settings.get(\"confirm_destructive\"):\n            # Execute command\n            executor = ERPNextExecutor(safe_mode=settings.get(\"safe_mode\", True))\n            result = executor.execute_command(command)\n            \n            # Update message with execution results\n            message.command_executed = command\n            message.command_result = json.dumps(result, indent=2)\n            message.is_error = not result.get(\"success\", False)\n            message.execution_time = result.get(\"executionTime\", 0)\n            message.save()\n            \n            # Log if enabled\n            if settings.get(\"log_commands\"):\n                frappe.logger(\"ai_assistant\").info(f\"Command executed: {command} | Result: {result}\")\n            \n            return result\n        else:\n            frappe.throw(_(\"Command execution not allowed in current configuration\"))\n            \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Confirm Execute Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to execute command: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef clear_history(session_id=None):\n    \"\"\"\n    Clear chat history for a session or all sessions for current user.\n    \n    Args:\n        session_id (str, optional): Specific session to clear\n    \n    Returns:\n        dict: Success status\n    \"\"\"\n    try:\n        # Check permissions\n        if not frappe.has_permission(\"AI Chat Message\", \"delete\"):\n            frappe.throw(_(\"Not permitted to delete chat messages\"), frappe.PermissionError)\n        \n        if session_id:\n            # Clear specific session\n            if not frappe.db.exists(\"AI Chat Session\", session_id):\n                frappe.throw(_(\"Chat session not found\"))\n            \n            # Check access\n            session_user = frappe.db.get_value(\"AI Chat Session\", session_id, \"user\")\n            if session_user != frappe.session.user and not frappe.has_permission(\"AI Chat Session\", \"delete\"):\n                frappe.throw(_(\"Not permitted to clear this session\"), frappe.PermissionError)\n            \n            # Delete messages\n            frappe.db.delete(\"AI Chat Message\", {\"session\": session_id})\n            \n            # Update session\n            frappe.db.set_value(\"AI Chat Session\", session_id, {\n                \"message_count\": 0,\n                \"session_end\": now_datetime(),\n                \"status\": \"Completed\"\n            })\n            \n            return {\"success\": True, \"message\": _(\"Session history cleared\")}\n        else:\n            # Clear all sessions for current user\n            user_sessions = frappe.get_all(\"AI Chat Session\", \n                filters={\"user\": frappe.session.user}, \n                pluck=\"name\")\n            \n            if user_sessions:\n                frappe.db.delete(\"AI Chat Message\", {\"session\": [\"in\", user_sessions]})\n                frappe.db.set_value(\"AI Chat Session\", {\"name\": [\"in\", user_sessions]}, {\n                    \"message_count\": 0,\n                    \"session_end\": now_datetime(),\n                    \"status\": \"Completed\"\n                })\n            \n            return {\"success\": True, \"message\": _(\"All chat history cleared\")}\n            \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Clear History Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to clear history: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_settings():\n    \"\"\"\n    Get AI Assistant settings.\n    \n    Returns:\n        dict: Current settings\n    \"\"\"\n    try:\n        # Check permissions - any authenticated user can read settings\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        settings = frappe.get_single(\"AI Assistant Settings\")\n        \n        return {\n            \"ollama_url\": settings.ollama_url or \"http://localhost:11434\",\n            \"model\": settings.model or \"llama2\",\n            \"safe_mode\": settings.safe_mode,\n            \"confirm_destructive\": settings.confirm_destructive,\n            \"log_commands\": settings.log_commands\n        }\n        \n    except Exception as e:\n        frappe.log_error(f\"Get Settings Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get settings: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef update_settings(ollama_url=None, model=None, safe_mode=None, \n                   confirm_destructive=None, log_commands=None):\n    \"\"\"\n    Update AI Assistant settings.\n    \n    Args:\n        ollama_url (str, optional): Ollama server URL\n        model (str, optional): AI model name\n        safe_mode (bool, optional): Enable safe mode\n        confirm_destructive (bool, optional): Confirm destructive operations\n        log_commands (bool, optional): Log executed commands\n    \n    Returns:\n        dict: Updated settings\n    \"\"\"\n    try:\n        # Check permissions - only System Manager can update settings\n        if not frappe.has_permission(\"AI Assistant Settings\", \"write\"):\n            frappe.throw(_(\"Not permitted to update AI Assistant settings\"), frappe.PermissionError)\n        \n        settings = frappe.get_single(\"AI Assistant Settings\")\n        \n        # Update provided fields\n        if ollama_url is not None:\n            settings.ollama_url = ollama_url\n        if model is not None:\n            settings.model = model\n        if safe_mode is not None:\n            settings.safe_mode = cint(safe_mode)\n        if confirm_destructive is not None:\n            settings.confirm_destructive = cint(confirm_destructive)\n        if log_commands is not None:\n            settings.log_commands = cint(log_commands)\n        \n        settings.save()\n        \n        return get_settings()\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Update Settings Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to update settings: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef start_scan():\n    \"\"\"\n    Start database schema scanning in background.\n    \n    Returns:\n        dict: Scan status\n    \"\"\"\n    try:\n        # Check permissions - only System Manager can start scan\n        if not frappe.has_permission(\"AI Assistant Settings\", \"write\"):\n            frappe.throw(_(\"Not permitted to start schema scan\"), frappe.PermissionError)\n        \n        # Enqueue background job\n        frappe.enqueue(\n            \"ai_assistant.ai_assistant.services.schema.scan_database_background\",\n            queue=\"default\",\n            timeout=600,  # 10 minutes\n            job_name=\"ai_assistant_schema_scan\"\n        )\n        \n        return {\n            \"success\": True,\n            \"message\": _(\"Schema scan started in background\")\n        }\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Start Scan Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to start schema scan: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_schema():\n    \"\"\"\n    Get cached database schema.\n    \n    Returns:\n        dict: Schema information\n    \"\"\"\n    try:\n        # Check permissions - authenticated users can read schema\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        schema_context = SchemaService.get_schema_context()\n        \n        return {\n            \"success\": True,\n            \"schema\": schema_context\n        }\n        \n    except Exception as e:\n        frappe.log_error(f\"Get Schema Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get schema: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_chat_sessions():\n    \"\"\"\n    Get chat sessions for current user.\n    \n    Returns:\n        list: List of chat sessions\n    \"\"\"\n    try:\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        sessions = frappe.get_all(\"AI Chat Session\",\n            filters={\"user\": frappe.session.user},\n            fields=[\"name\", \"title\", \"status\", \"session_start\", \"session_end\", \"message_count\"],\n            order_by=\"session_start desc\",\n            limit=50\n        )\n        \n        return {\"success\": True, \"sessions\": sessions}\n        \n    except Exception as e:\n        frappe.log_error(f\"Get Chat Sessions Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get chat sessions: {0}\").format(str(e)))\n\n\n@frappe.whitelist()\ndef get_chat_messages(session_id):\n    \"\"\"\n    Get chat messages for a session.\n    \n    Args:\n        session_id (str): Chat session ID\n    \n    Returns:\n        list: List of chat messages\n    \"\"\"\n    try:\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Authentication required\"), frappe.AuthenticationError)\n        \n        # Check session exists and access\n        if not frappe.db.exists(\"AI Chat Session\", session_id):\n            frappe.throw(_(\"Chat session not found\"))\n        \n        session_user = frappe.db.get_value(\"AI Chat Session\", session_id, \"user\")\n        if session_user != frappe.session.user and not frappe.has_permission(\"AI Chat Session\", \"read\"):\n            frappe.throw(_(\"Not permitted to access this chat session\"), frappe.PermissionError)\n        \n        messages = frappe.get_all(\"AI Chat Message\",\n            filters={\"session\": session_id},\n            fields=[\"name\", \"role\", \"content\", \"timestamp\", \"command_executed\", \n                   \"command_result\", \"is_error\", \"execution_time\"],\n            order_by=\"timestamp asc\"\n        )\n        \n        return {\"success\": True, \"messages\": messages}\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Get Chat Messages Error: {str(e)}\", \"AI Assistant\")\n        frappe.throw(_(\"Failed to get chat messages: {0}\").format(str(e)))","size_bytes":16495},"attached_assets/BenchChatAI/ai_assistant/config/__init__.py":{"content":"","size_bytes":0},"attached_assets/BenchChatAI/ai_assistant/config/desktop.py":{"content":"from frappe import _\n\ndef get_data():\n\treturn [\n\t\t{\n\t\t\t\"module_name\": \"AI Assistant\",\n\t\t\t\"color\": \"grey\",\n\t\t\t\"icon\": \"fa fa-robot\",\n\t\t\t\"type\": \"module\",\n\t\t\t\"label\": _(\"AI Assistant\")\n\t\t}\n\t]","size_bytes":189},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/__init__.py":{"content":"","size_bytes":0},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/services/__init__.py":{"content":"# AI Assistant Services Module\n# \n# This module contains the core services for the AI Assistant ERPNext app:\n# - ollama.py: Ollama API integration for AI model interactions\n# - erpnext_exec.py: Secure command execution service\n# - schema.py: Database schema scanning and context building\n\n__version__ = \"1.0.0\"","size_bytes":310},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/services/erpnext_exec.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport re\nimport time\nimport subprocess\nimport json\nimport shlex\nimport frappe\nfrom typing import Dict, Any, List, Optional, Tuple\nfrom frappe import _\nfrom frappe.utils import cint, flt\n\n\nclass ERPNextExecutor:\n    \"\"\"\n    Secure command execution service for AI Assistant.\n    \n    Handles safe execution of database queries and limited system commands\n    with comprehensive security checks and safe mode enforcement.\n    \"\"\"\n    \n    # SQL commands that are allowed\n    ALLOWED_SQL_COMMANDS = {\n        'SELECT', 'SHOW', 'DESCRIBE', 'DESC', 'EXPLAIN'\n    }\n    \n    # Destructive SQL commands that require confirmation\n    DESTRUCTIVE_SQL_COMMANDS = {\n        'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER', \n        'TRUNCATE', 'REPLACE', 'MERGE', 'CALL', 'EXECUTE'\n    }\n    \n    # Allowed bench commands (very restrictive)\n    ALLOWED_BENCH_COMMANDS = {\n        'version', '--version', '--help', '-h', 'help'\n    }\n    \n    # Shell metacharacters to detect and block\n    SHELL_METACHARACTERS = {\n        ';', '|', '&', '$', '`', '>', '<', '*', '?', '[', ']', \n        '(', ')', '{', '}', '\\\\', '\"', \"'\", '\\n', '\\r'\n    }\n    \n    def __init__(self, safe_mode: bool = True, timeout: int = 30):\n        \"\"\"\n        Initialize ERPNext command executor.\n        \n        Args:\n            safe_mode (bool): Enable safe mode restrictions\n            timeout (int): Command execution timeout in seconds\n        \"\"\"\n        self.safe_mode = safe_mode\n        self.timeout = timeout\n    \n    def execute_command(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Execute a command with security checks.\n        \n        Args:\n            command (str): Command to execute\n        \n        Returns:\n            Dict[str, Any]: Execution result with structure:\n                {\n                    \"success\": bool,\n                    \"output\": str,\n                    \"error\": str,\n                    \"executionTime\": int  # milliseconds\n                }\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Basic validation\n            if not command or not isinstance(command, str):\n                return self._error_result(\"Invalid command\", start_time)\n            \n            command = command.strip()\n            if not command:\n                return self._error_result(\"Empty command\", start_time)\n            \n            # Security checks\n            security_check = self._perform_security_checks(command)\n            if not security_check[\"safe\"]:\n                return self._error_result(security_check[\"reason\"], start_time)\n            \n            # Determine command type and execute\n            if self._is_sql_command(command):\n                return self._execute_sql_command(command, start_time)\n            elif self._is_bench_command(command):\n                if self.safe_mode:\n                    return self._error_result(\"Bench commands disabled in safe mode\", start_time)\n                return self._execute_bench_command(command, start_time)\n            else:\n                return self._error_result(\"Command type not recognized or not allowed\", start_time)\n                \n        except Exception as e:\n            frappe.log_error(f\"Command execution error: {str(e)}\", \"ERPNext Executor\")\n            return self._error_result(f\"Execution error: {str(e)}\", start_time)\n    \n    def _perform_security_checks(self, command: str) -> Dict[str, Any]:\n        \"\"\"\n        Perform comprehensive security checks on command.\n        \n        Args:\n            command (str): Command to check\n        \n        Returns:\n            Dict[str, Any]: Security check result\n        \"\"\"\n        # Check for shell metacharacters\n        for char in self.SHELL_METACHARACTERS:\n            if char in command:\n                return {\n                    \"safe\": False,\n                    \"reason\": f\"Shell metacharacter '{char}' not allowed for security\"\n                }\n        \n        # Check command length\n        if len(command) > 2000:\n            return {\n                \"safe\": False,\n                \"reason\": \"Command too long (max 2000 characters)\"\n            }\n        \n        # Check for suspicious patterns\n        suspicious_patterns = [\n            r'--\\s*$',  # SQL comments at end\n            r'/\\*.*?\\*/',  # SQL block comments\n            r'\\bUNION\\b.*\\bSELECT\\b',  # SQL injection patterns\n            r'\\bEXEC\\b|\\bXP_\\b|\\bSP_\\b',  # System procedures\n            r'\\bFILE\\b|\\bINTO\\s+OUTFILE\\b',  # File operations\n            r'\\bLOAD_FILE\\b|\\bLOAD\\s+DATA\\b',  # File loading\n        ]\n        \n        for pattern in suspicious_patterns:\n            if re.search(pattern, command, re.IGNORECASE):\n                return {\n                    \"safe\": False,\n                    \"reason\": f\"Potentially dangerous pattern detected\"\n                }\n        \n        return {\"safe\": True, \"reason\": \"\"}\n    \n    def _is_sql_command(self, command: str) -> bool:\n        \"\"\"Check if command is a SQL command.\"\"\"\n        first_word = command.strip().split()[0].upper()\n        return first_word in self.ALLOWED_SQL_COMMANDS or first_word in self.DESTRUCTIVE_SQL_COMMANDS\n    \n    def _is_bench_command(self, command: str) -> bool:\n        \"\"\"Check if command is a bench command.\"\"\"\n        return command.strip().startswith('bench ') or command.strip() in self.ALLOWED_BENCH_COMMANDS\n    \n    def _execute_sql_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Execute SQL command using Frappe's database interface.\n        \n        Args:\n            command (str): SQL command to execute\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Execution result\n        \"\"\"\n        try:\n            first_word = command.strip().split()[0].upper()\n            \n            # Check if destructive command\n            if first_word in self.DESTRUCTIVE_SQL_COMMANDS:\n                if self.safe_mode:\n                    return self._error_result(\n                        f\"Destructive SQL command '{first_word}' not allowed in safe mode\", \n                        start_time\n                    )\n                else:\n                    return self._error_result(\n                        f\"Destructive SQL command '{first_word}' requires manual confirmation\", \n                        start_time\n                    )\n            \n            # Process safe SQL commands\n            if first_word == 'SELECT':\n                command = self._add_limit_to_select(command)\n            \n            # Execute using frappe.db.sql\n            if first_word in ['SHOW', 'DESCRIBE', 'DESC']:\n                # These commands return simple results\n                result = frappe.db.sql(command, as_dict=False)\n                output = self._format_sql_result(result)\n            else:\n                # SELECT and EXPLAIN return structured data\n                result = frappe.db.sql(command, as_dict=True)\n                output = self._format_sql_result(result)\n            \n            execution_time = int((time.time() - start_time) * 1000)\n            \n            return {\n                \"success\": True,\n                \"output\": output,\n                \"error\": \"\",\n                \"executionTime\": execution_time\n            }\n            \n        except Exception as e:\n            error_msg = str(e)\n            frappe.log_error(f\"SQL execution error: {error_msg}\", \"ERPNext Executor\")\n            return self._error_result(f\"SQL error: {error_msg}\", start_time)\n    \n    def _execute_bench_command(self, command: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Execute allowed bench command using subprocess.\n        \n        Args:\n            command (str): Bench command to execute\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Execution result\n        \"\"\"\n        try:\n            # Parse command\n            if command.startswith('bench '):\n                cmd_parts = shlex.split(command)\n            else:\n                cmd_parts = ['bench'] + shlex.split(command)\n            \n            # Validate command parts\n            if not self._is_allowed_bench_command(cmd_parts[1:]):\n                return self._error_result(\"Bench command not allowed\", start_time)\n            \n            # Execute with timeout\n            result = subprocess.run(\n                cmd_parts,\n                capture_output=True,\n                text=True,\n                timeout=self.timeout,\n                cwd=frappe.get_site_path('..')\n            )\n            \n            execution_time = int((time.time() - start_time) * 1000)\n            \n            if result.returncode == 0:\n                return {\n                    \"success\": True,\n                    \"output\": result.stdout,\n                    \"error\": result.stderr if result.stderr else \"\",\n                    \"executionTime\": execution_time\n                }\n            else:\n                return {\n                    \"success\": False,\n                    \"output\": result.stdout if result.stdout else \"\",\n                    \"error\": result.stderr if result.stderr else \"Command failed\",\n                    \"executionTime\": execution_time\n                }\n                \n        except subprocess.TimeoutExpired:\n            return self._error_result(\"Command timed out\", start_time)\n        except subprocess.CalledProcessError as e:\n            return self._error_result(f\"Command failed: {str(e)}\", start_time)\n        except Exception as e:\n            frappe.log_error(f\"Bench command error: {str(e)}\", \"ERPNext Executor\")\n            return self._error_result(f\"Execution error: {str(e)}\", start_time)\n    \n    def _is_allowed_bench_command(self, cmd_parts: List[str]) -> bool:\n        \"\"\"Check if bench command parts are allowed.\"\"\"\n        if not cmd_parts:\n            return False\n        \n        # Check first argument\n        first_arg = cmd_parts[0]\n        if first_arg in self.ALLOWED_BENCH_COMMANDS:\n            return True\n        \n        # Allow specific safe commands\n        safe_patterns = [\n            r'^--help$',\n            r'^-h$',\n            r'^version$',\n            r'^--version$'\n        ]\n        \n        for pattern in safe_patterns:\n            if re.match(pattern, first_arg):\n                return True\n        \n        return False\n    \n    def _add_limit_to_select(self, command: str) -> str:\n        \"\"\"\n        Add LIMIT clause to SELECT queries if not present.\n        \n        Args:\n            command (str): SQL SELECT command\n        \n        Returns:\n            str: Modified command with LIMIT\n        \"\"\"\n        # Check if LIMIT already exists\n        if re.search(r'\\bLIMIT\\b', command, re.IGNORECASE):\n            return command\n        \n        # Add LIMIT 100 at the end\n        command = command.rstrip(';').rstrip()\n        return f\"{command} LIMIT 100\"\n    \n    def _format_sql_result(self, result: Any) -> str:\n        \"\"\"\n        Format SQL result for display.\n        \n        Args:\n            result: SQL query result\n        \n        Returns:\n            str: Formatted result string\n        \"\"\"\n        if not result:\n            return \"No results found.\"\n        \n        try:\n            if isinstance(result, list):\n                if len(result) == 0:\n                    return \"No results found.\"\n                \n                # Check if it's a list of dictionaries (as_dict=True)\n                if isinstance(result[0], dict):\n                    # Format as JSON for structured data\n                    return json.dumps(result, indent=2, default=str)\n                else:\n                    # Format as simple table for tuple results\n                    output = []\n                    for row in result:\n                        if isinstance(row, (tuple, list)):\n                            output.append(\" | \".join(str(col) for col in row))\n                        else:\n                            output.append(str(row))\n                    return \"\\n\".join(output)\n            else:\n                return str(result)\n                \n        except Exception as e:\n            frappe.log_error(f\"Result formatting error: {str(e)}\", \"ERPNext Executor\")\n            return f\"Result formatting error: {str(e)}\"\n    \n    def _error_result(self, error_message: str, start_time: float) -> Dict[str, Any]:\n        \"\"\"\n        Create error result dictionary.\n        \n        Args:\n            error_message (str): Error message\n            start_time (float): Execution start time\n        \n        Returns:\n            Dict[str, Any]: Error result\n        \"\"\"\n        execution_time = int((time.time() - start_time) * 1000)\n        return {\n            \"success\": False,\n            \"output\": \"\",\n            \"error\": error_message,\n            \"executionTime\": execution_time\n        }\n    \n    def validate_sql_query(self, query: str) -> Dict[str, Any]:\n        \"\"\"\n        Validate SQL query without executing it.\n        \n        Args:\n            query (str): SQL query to validate\n        \n        Returns:\n            Dict[str, Any]: Validation result\n        \"\"\"\n        try:\n            # Basic syntax check\n            query = query.strip()\n            if not query:\n                return {\"valid\": False, \"reason\": \"Empty query\"}\n            \n            # Check command type\n            first_word = query.split()[0].upper()\n            \n            if first_word in self.DESTRUCTIVE_SQL_COMMANDS:\n                return {\n                    \"valid\": False,\n                    \"reason\": f\"Destructive command '{first_word}' not allowed\",\n                    \"isDestructive\": True\n                }\n            \n            if first_word not in self.ALLOWED_SQL_COMMANDS:\n                return {\n                    \"valid\": False,\n                    \"reason\": f\"Command '{first_word}' not allowed\"\n                }\n            \n            # Security checks\n            security_check = self._perform_security_checks(query)\n            if not security_check[\"safe\"]:\n                return {\n                    \"valid\": False,\n                    \"reason\": security_check[\"reason\"]\n                }\n            \n            return {\n                \"valid\": True,\n                \"reason\": \"Query is valid\",\n                \"commandType\": first_word.lower(),\n                \"isDestructive\": False\n            }\n            \n        except Exception as e:\n            return {\n                \"valid\": False,\n                \"reason\": f\"Validation error: {str(e)}\"\n            }\n\n\ndef get_executor(safe_mode: Optional[bool] = None) -> ERPNextExecutor:\n    \"\"\"\n    Get ERPNext executor with settings from AI Assistant Settings.\n    \n    Args:\n        safe_mode (Optional[bool]): Override safe mode setting\n    \n    Returns:\n        ERPNextExecutor: Configured executor instance\n    \"\"\"\n    try:\n        if safe_mode is None:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            safe_mode = settings.safe_mode\n        \n        return ERPNextExecutor(safe_mode=safe_mode)\n    except Exception as e:\n        frappe.log_error(f\"Failed to get executor: {str(e)}\", \"ERPNext Executor\")\n        # Return default safe configuration\n        return ERPNextExecutor(safe_mode=True)","size_bytes":15431},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/services/ollama.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport re\nimport requests\nimport frappe\nfrom typing import Dict, Any, Optional\nfrom frappe import _\nfrom frappe.utils import cint\n\n\nclass OllamaService:\n    \"\"\"\n    Service class for interacting with Ollama API.\n    \n    Provides methods for generating AI responses and analyzing commands\n    for the AI Assistant ERPNext application.\n    \"\"\"\n    \n    def __init__(self, url: str = \"http://localhost:11434\", model: str = \"llama2\", timeout: int = 30):\n        \"\"\"\n        Initialize Ollama service.\n        \n        Args:\n            url (str): Ollama server URL\n            model (str): AI model name\n            timeout (int): Request timeout in seconds\n        \"\"\"\n        self.url = url.rstrip('/')\n        self.model = model\n        self.timeout = timeout\n        self.session = requests.Session()\n        \n        # Configure session\n        self.session.headers.update({\n            'Content-Type': 'application/json',\n            'User-Agent': 'ERPNext-AI-Assistant/1.0'\n        })\n    \n    def generate_response(self, prompt: str, schema_context: str = \"\") -> str:\n        \"\"\"\n        Generate AI response for given prompt.\n        \n        Args:\n            prompt (str): User prompt/question\n            schema_context (str): Database schema context for better responses\n        \n        Returns:\n            str: AI generated response\n        \n        Raises:\n            Exception: If API call fails or times out\n        \"\"\"\n        try:\n            # Build context-aware prompt\n            system_prompt = self._build_system_prompt(schema_context)\n            full_prompt = f\"{system_prompt}\\n\\nUser: {prompt}\\nAssistant:\"\n            \n            payload = {\n                \"model\": self.model,\n                \"prompt\": full_prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"temperature\": 0.7,\n                    \"max_tokens\": 1000,\n                    \"stop\": [\"User:\", \"Human:\"]\n                }\n            }\n            \n            response = self.session.post(\n                f\"{self.url}/api/generate\",\n                json=payload,\n                timeout=self.timeout\n            )\n            \n            if response.status_code == 200:\n                result = response.json()\n                return result.get('response', '').strip()\n            else:\n                error_msg = f\"Ollama API returned {response.status_code}: {response.text}\"\n                frappe.log_error(error_msg, \"Ollama Service\")\n                raise Exception(f\"Failed to generate response: {error_msg}\")\n                \n        except requests.exceptions.Timeout:\n            frappe.log_error(\"Ollama API timeout\", \"Ollama Service\")\n            raise Exception(\"AI service is taking too long to respond. Please try again.\")\n        except requests.exceptions.ConnectionError:\n            frappe.log_error(f\"Cannot connect to Ollama at {self.url}\", \"Ollama Service\")\n            raise Exception(f\"Cannot connect to AI service at {self.url}. Please check if Ollama is running.\")\n        except requests.exceptions.RequestException as e:\n            frappe.log_error(f\"Ollama API request error: {str(e)}\", \"Ollama Service\")\n            raise Exception(f\"AI service error: {str(e)}\")\n        except Exception as e:\n            frappe.log_error(f\"Ollama generate_response error: {str(e)}\", \"Ollama Service\")\n            raise\n    \n    def analyze_command(self, prompt: str, schema_context: str = \"\") -> Dict[str, Any]:\n        \"\"\"\n        Analyze if a prompt contains a command that should be executed.\n        \n        Args:\n            prompt (str): User prompt to analyze\n            schema_context (str): Database schema context\n        \n        Returns:\n            Dict[str, Any]: Command analysis with structure:\n                {\n                    \"command\": str,\n                    \"description\": str,\n                    \"isDestructive\": bool,\n                    \"requiresConfirmation\": bool,\n                    \"category\": str\n                }\n        \"\"\"\n        try:\n            analysis_prompt = self._build_command_analysis_prompt(prompt, schema_context)\n            \n            payload = {\n                \"model\": self.model,\n                \"prompt\": analysis_prompt,\n                \"stream\": False,\n                \"options\": {\n                    \"temperature\": 0.1,  # Lower temperature for more consistent JSON\n                    \"max_tokens\": 500\n                }\n            }\n            \n            response = self.session.post(\n                f\"{self.url}/api/generate\",\n                json=payload,\n                timeout=self.timeout\n            )\n            \n            if response.status_code == 200:\n                result = response.json()\n                response_text = result.get('response', '').strip()\n                \n                # Extract JSON from response\n                command_analysis = self.extract_json_from_response(response_text)\n                \n                # Validate and set defaults\n                return self._validate_command_analysis(command_analysis)\n            else:\n                frappe.log_error(f\"Command analysis API error: {response.status_code} - {response.text}\", \"Ollama Service\")\n                return self._default_command_analysis()\n                \n        except requests.exceptions.Timeout:\n            frappe.log_error(\"Command analysis timeout\", \"Ollama Service\")\n            return self._default_command_analysis()\n        except Exception as e:\n            frappe.log_error(f\"Command analysis error: {str(e)}\", \"Ollama Service\")\n            return self._default_command_analysis()\n    \n    def extract_json_from_response(self, response_text: str) -> Dict[str, Any]:\n        \"\"\"\n        Extract JSON object from AI response text.\n        \n        Args:\n            response_text (str): Raw AI response text\n        \n        Returns:\n            Dict[str, Any]: Parsed JSON object\n        \"\"\"\n        try:\n            # Try to find JSON block in response\n            json_patterns = [\n                r'```json\\s*(\\{.*?\\})\\s*```',\n                r'```\\s*(\\{.*?\\})\\s*```',\n                r'(\\{.*?\\})',\n                r'JSON:\\s*(\\{.*?\\})'\n            ]\n            \n            for pattern in json_patterns:\n                match = re.search(pattern, response_text, re.DOTALL)\n                if match:\n                    json_str = match.group(1)\n                    try:\n                        return json.loads(json_str)\n                    except json.JSONDecodeError:\n                        continue\n            \n            # If no JSON found, try parsing the entire response\n            return json.loads(response_text)\n            \n        except json.JSONDecodeError:\n            # Return empty dict if JSON parsing fails\n            frappe.log_error(f\"Failed to parse JSON from response: {response_text}\", \"Ollama Service\")\n            return {}\n        except Exception as e:\n            frappe.log_error(f\"JSON extraction error: {str(e)}\", \"Ollama Service\")\n            return {}\n    \n    def _build_system_prompt(self, schema_context: str) -> str:\n        \"\"\"Build system prompt with ERPNext context.\"\"\"\n        base_prompt = \"\"\"You are an AI assistant for ERPNext, an open-source ERP system. You help users with:\n1. Understanding their business data and reports\n2. Writing database queries to extract information\n3. Analyzing business processes and workflows\n4. Suggesting best practices for ERPNext usage\n\nGuidelines:\n- Always prioritize data security and user permissions\n- Suggest only safe, non-destructive operations\n- When writing SQL queries, always include appropriate LIMIT clauses\n- Focus on helping users understand their business data\n- Be concise but comprehensive in your responses\"\"\"\n        \n        if schema_context:\n            base_prompt += f\"\\n\\nDatabase Schema Context:\\n{schema_context}\"\n            \n        return base_prompt\n    \n    def _build_command_analysis_prompt(self, prompt: str, schema_context: str) -> str:\n        \"\"\"Build prompt for command analysis.\"\"\"\n        analysis_prompt = f\"\"\"Analyze the following user request and determine if it contains a command that should be executed in ERPNext.\n\nUser Request: \"{prompt}\"\n\n{schema_context and f\"Database Schema: {schema_context[:1000]}\" or \"\"}\n\nReturn a JSON object with this exact structure:\n{{\n    \"command\": \"extracted command or empty string\",\n    \"description\": \"brief description of what the command does\",\n    \"isDestructive\": false,\n    \"requiresConfirmation\": false,\n    \"category\": \"query|report|analysis|other\"\n}}\n\nCategories:\n- query: Database SELECT queries\n- report: Generate reports or summaries\n- analysis: Data analysis or calculations\n- other: General questions or non-command requests\n\nMark isDestructive as true ONLY for commands that modify data (INSERT, UPDATE, DELETE, CREATE, DROP, ALTER).\nMark requiresConfirmation as true for any potentially risky operations.\n\nExample responses:\nFor \"Show me all customers\": {{\"command\": \"SELECT * FROM `tabCustomer` LIMIT 100\", \"description\": \"List all customers\", \"isDestructive\": false, \"requiresConfirmation\": false, \"category\": \"query\"}}\n\nFor \"What is ERPNext?\": {{\"command\": \"\", \"description\": \"General question about ERPNext\", \"isDestructive\": false, \"requiresConfirmation\": false, \"category\": \"other\"}}\n\nReturn only the JSON object:\"\"\"\n        \n        return analysis_prompt\n    \n    def _validate_command_analysis(self, analysis: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Validate and normalize command analysis result.\"\"\"\n        return {\n            \"command\": str(analysis.get(\"command\", \"\")),\n            \"description\": str(analysis.get(\"description\", \"No description available\")),\n            \"isDestructive\": bool(analysis.get(\"isDestructive\", False)),\n            \"requiresConfirmation\": bool(analysis.get(\"requiresConfirmation\", False)),\n            \"category\": str(analysis.get(\"category\", \"other\"))\n        }\n    \n    def _default_command_analysis(self) -> Dict[str, Any]:\n        \"\"\"Return default command analysis when parsing fails.\"\"\"\n        return {\n            \"command\": \"\",\n            \"description\": \"Unable to analyze command\",\n            \"isDestructive\": False,\n            \"requiresConfirmation\": False,\n            \"category\": \"other\"\n        }\n    \n    def test_connection(self) -> bool:\n        \"\"\"\n        Test connection to Ollama service.\n        \n        Returns:\n            bool: True if connection successful, False otherwise\n        \"\"\"\n        try:\n            response = self.session.get(f\"{self.url}/api/tags\", timeout=5)\n            return response.status_code == 200\n        except Exception as e:\n            frappe.log_error(f\"Ollama connection test failed: {str(e)}\", \"Ollama Service\")\n            return False\n    \n    def get_available_models(self) -> list:\n        \"\"\"\n        Get list of available models from Ollama.\n        \n        Returns:\n            list: List of available model names\n        \"\"\"\n        try:\n            response = self.session.get(f\"{self.url}/api/tags\", timeout=10)\n            if response.status_code == 200:\n                data = response.json()\n                models = data.get('models', [])\n                return [model.get('name', '') for model in models if model.get('name')]\n            else:\n                return []\n        except Exception as e:\n            frappe.log_error(f\"Failed to get available models: {str(e)}\", \"Ollama Service\")\n            return []\n\n\ndef get_ollama_service() -> OllamaService:\n    \"\"\"\n    Get configured Ollama service instance.\n    \n    Returns:\n        OllamaService: Configured service instance\n    \"\"\"\n    try:\n        settings = frappe.get_single(\"AI Assistant Settings\")\n        return OllamaService(\n            url=settings.ollama_url or \"http://localhost:11434\",\n            model=settings.model or \"llama2\",\n            timeout=30\n        )\n    except Exception as e:\n        frappe.log_error(f\"Failed to get Ollama service: {str(e)}\", \"Ollama Service\")\n        # Return default configuration\n        return OllamaService()","size_bytes":12189},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/services/schema.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport frappe\nfrom typing import Dict, Any, List, Optional\nfrom frappe import _\nfrom frappe.utils import now_datetime, cint\n\n\nclass SchemaService:\n    \"\"\"\n    Database schema scanning service for AI Assistant.\n    \n    Provides methods to scan and cache database schema information\n    to provide better context for AI responses.\n    \"\"\"\n    \n    @staticmethod\n    def scan_database(include_custom: bool = True, max_tables: int = 100) -> Dict[str, Any]:\n        \"\"\"\n        Scan database schema and return structured information.\n        \n        Args:\n            include_custom (bool): Include custom DocTypes\n            max_tables (int): Maximum number of tables to scan\n        \n        Returns:\n            Dict[str, Any]: Schema information\n        \"\"\"\n        try:\n            schema_info = {\n                \"scan_time\": now_datetime().isoformat(),\n                \"doctypes\": {},\n                \"tables\": {},\n                \"summary\": {\n                    \"total_doctypes\": 0,\n                    \"total_tables\": 0,\n                    \"custom_doctypes\": 0\n                }\n            }\n            \n            # Scan DocTypes using Frappe meta\n            schema_info[\"doctypes\"] = SchemaService._scan_doctypes(include_custom)\n            schema_info[\"summary\"][\"total_doctypes\"] = len(schema_info[\"doctypes\"])\n            \n            # Count custom DocTypes\n            custom_count = sum(1 for dt in schema_info[\"doctypes\"].values() \n                             if dt.get(\"is_custom\", False))\n            schema_info[\"summary\"][\"custom_doctypes\"] = custom_count\n            \n            # Scan raw database tables\n            schema_info[\"tables\"] = SchemaService._scan_database_tables(max_tables)\n            schema_info[\"summary\"][\"total_tables\"] = len(schema_info[\"tables\"])\n            \n            return schema_info\n            \n        except Exception as e:\n            frappe.log_error(f\"Database scan error: {str(e)}\", \"Schema Service\")\n            raise Exception(f\"Failed to scan database: {str(e)}\")\n    \n    @staticmethod\n    def _scan_doctypes(include_custom: bool = True) -> Dict[str, Any]:\n        \"\"\"\n        Scan DocTypes using Frappe's meta system.\n        \n        Args:\n            include_custom (bool): Include custom DocTypes\n        \n        Returns:\n            Dict[str, Any]: DocType information\n        \"\"\"\n        doctypes_info = {}\n        \n        try:\n            # Get all DocTypes\n            filters = {}\n            if not include_custom:\n                filters[\"custom\"] = 0\n            \n            doctype_list = frappe.get_all(\"DocType\", \n                filters=filters,\n                fields=[\"name\", \"module\", \"custom\", \"is_single\", \"is_tree\", \n                       \"is_child\", \"is_virtual\", \"description\"],\n                limit_page_length=200\n            )\n            \n            for dt in doctype_list:\n                try:\n                    # Get meta information\n                    meta = frappe.get_meta(dt[\"name\"])\n                    \n                    doctype_info = {\n                        \"name\": dt[\"name\"],\n                        \"module\": dt[\"module\"],\n                        \"is_custom\": bool(dt.get(\"custom\")),\n                        \"is_single\": bool(dt.get(\"is_single\")),\n                        \"is_tree\": bool(dt.get(\"is_tree\")),\n                        \"is_child\": bool(dt.get(\"is_child\")),\n                        \"is_virtual\": bool(dt.get(\"is_virtual\")),\n                        \"description\": dt.get(\"description\", \"\"),\n                        \"fields\": [],\n                        \"links\": []\n                    }\n                    \n                    # Get field information\n                    for field in meta.fields:\n                        if field.fieldtype not in [\"Section Break\", \"Column Break\", \"Tab Break\"]:\n                            field_info = {\n                                \"fieldname\": field.fieldname,\n                                \"fieldtype\": field.fieldtype,\n                                \"label\": field.label,\n                                \"reqd\": bool(field.reqd),\n                                \"options\": field.options if field.options else \"\"\n                            }\n                            doctype_info[\"fields\"].append(field_info)\n                    \n                    # Get link fields for relationships\n                    for field in meta.fields:\n                        if field.fieldtype == \"Link\" and field.options:\n                            doctype_info[\"links\"].append({\n                                \"field\": field.fieldname,\n                                \"target\": field.options,\n                                \"label\": field.label\n                            })\n                    \n                    doctypes_info[dt[\"name\"]] = doctype_info\n                    \n                except Exception as field_error:\n                    frappe.log_error(f\"Error scanning DocType {dt['name']}: {str(field_error)}\", \"Schema Service\")\n                    continue\n            \n            return doctypes_info\n            \n        except Exception as e:\n            frappe.log_error(f\"DocType scan error: {str(e)}\", \"Schema Service\")\n            return {}\n    \n    @staticmethod\n    def _scan_database_tables(max_tables: int = 100) -> Dict[str, Any]:\n        \"\"\"\n        Scan raw database tables using SQL.\n        \n        Args:\n            max_tables (int): Maximum number of tables to scan\n        \n        Returns:\n            Dict[str, Any]: Table information\n        \"\"\"\n        tables_info = {}\n        \n        try:\n            # Get list of tables\n            tables_result = frappe.db.sql(\"SHOW TABLES\", as_dict=False)\n            table_names = [table[0] for table in tables_result[:max_tables]]\n            \n            for table_name in table_names:\n                try:\n                    # Skip certain system tables\n                    if table_name.startswith('__') or table_name in ['mysql', 'information_schema', 'performance_schema']:\n                        continue\n                    \n                    # Get table structure\n                    describe_result = frappe.db.sql(f\"DESCRIBE `{table_name}`\", as_dict=True)\n                    \n                    table_info = {\n                        \"name\": table_name,\n                        \"columns\": [],\n                        \"primary_keys\": [],\n                        \"indexes\": []\n                    }\n                    \n                    # Process columns\n                    for column in describe_result:\n                        column_info = {\n                            \"name\": column.get(\"Field\", \"\"),\n                            \"type\": column.get(\"Type\", \"\"),\n                            \"null\": column.get(\"Null\", \"\") == \"YES\",\n                            \"key\": column.get(\"Key\", \"\"),\n                            \"default\": column.get(\"Default\", \"\"),\n                            \"extra\": column.get(\"Extra\", \"\")\n                        }\n                        table_info[\"columns\"].append(column_info)\n                        \n                        # Track primary keys\n                        if column.get(\"Key\") == \"PRI\":\n                            table_info[\"primary_keys\"].append(column.get(\"Field\"))\n                    \n                    tables_info[table_name] = table_info\n                    \n                except Exception as table_error:\n                    frappe.log_error(f\"Error scanning table {table_name}: {str(table_error)}\", \"Schema Service\")\n                    continue\n            \n            return tables_info\n            \n        except Exception as e:\n            frappe.log_error(f\"Database tables scan error: {str(e)}\", \"Schema Service\")\n            return {}\n    \n    @staticmethod\n    def get_schema_context(format_type: str = \"summary\") -> str:\n        \"\"\"\n        Get cached schema context for AI assistant.\n        \n        Args:\n            format_type (str): Format type - \"summary\", \"detailed\", or \"json\"\n        \n        Returns:\n            str: Formatted schema context\n        \"\"\"\n        try:\n            # Try to get cached schema from settings\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            \n            # Check if we have cached schema (assuming we add a field for this)\n            cached_schema = getattr(settings, 'cached_schema', None)\n            \n            if cached_schema:\n                try:\n                    schema_data = json.loads(cached_schema)\n                    return SchemaService._format_schema_context(schema_data, format_type)\n                except json.JSONDecodeError:\n                    pass\n            \n            # If no cached schema, generate basic context from key DocTypes\n            return SchemaService._generate_basic_context(format_type)\n            \n        except Exception as e:\n            frappe.log_error(f\"Get schema context error: {str(e)}\", \"Schema Service\")\n            return \"Schema context unavailable\"\n    \n    @staticmethod\n    def _generate_basic_context(format_type: str = \"summary\") -> str:\n        \"\"\"Generate basic schema context without full scan.\"\"\"\n        try:\n            # Key ERPNext DocTypes that are commonly queried\n            key_doctypes = [\n                \"Customer\", \"Supplier\", \"Item\", \"Sales Invoice\", \"Purchase Invoice\",\n                \"Sales Order\", \"Purchase Order\", \"Delivery Note\", \"Purchase Receipt\",\n                \"Payment Entry\", \"Journal Entry\", \"Employee\", \"User\", \"Company\"\n            ]\n            \n            context_parts = []\n            \n            if format_type == \"summary\":\n                context_parts.append(\"ERPNext Core Entities:\")\n                \n                for doctype in key_doctypes:\n                    try:\n                        if frappe.db.exists(\"DocType\", doctype):\n                            meta = frappe.get_meta(doctype)\n                            key_fields = [f.fieldname for f in meta.fields[:5] \n                                        if f.fieldtype not in [\"Section Break\", \"Column Break\"]]\n                            \n                            context_parts.append(f\"- {doctype}: {', '.join(key_fields)}\")\n                    except Exception:\n                        continue\n                        \n                return \"\\n\".join(context_parts)\n            \n            elif format_type == \"detailed\":\n                context_parts.append(\"ERPNext Schema Context (Basic):\")\n                \n                for doctype in key_doctypes:\n                    try:\n                        if frappe.db.exists(\"DocType\", doctype):\n                            meta = frappe.get_meta(doctype)\n                            context_parts.append(f\"\\n{doctype}:\")\n                            context_parts.append(f\"  Table: `tab{doctype}`\")\n                            \n                            # Key fields\n                            key_fields = []\n                            for field in meta.fields[:10]:\n                                if field.fieldtype not in [\"Section Break\", \"Column Break\", \"Tab Break\"]:\n                                    key_fields.append(f\"    {field.fieldname} ({field.fieldtype})\")\n                            \n                            if key_fields:\n                                context_parts.append(\"  Key Fields:\")\n                                context_parts.extend(key_fields)\n                    except Exception:\n                        continue\n                        \n                return \"\\n\".join(context_parts)\n            \n            else:  # json format\n                schema_data = {\"doctypes\": []}\n                for doctype in key_doctypes:\n                    try:\n                        if frappe.db.exists(\"DocType\", doctype):\n                            meta = frappe.get_meta(doctype)\n                            fields = [{\"name\": f.fieldname, \"type\": f.fieldtype, \"label\": f.label}\n                                    for f in meta.fields[:10] \n                                    if f.fieldtype not in [\"Section Break\", \"Column Break\"]]\n                            \n                            schema_data[\"doctypes\"].append({\n                                \"name\": doctype,\n                                \"table\": f\"tab{doctype}\",\n                                \"fields\": fields\n                            })\n                    except Exception:\n                        continue\n                \n                return json.dumps(schema_data, indent=2)\n                \n        except Exception as e:\n            frappe.log_error(f\"Generate basic context error: {str(e)}\", \"Schema Service\")\n            return \"Basic schema context unavailable\"\n    \n    @staticmethod\n    def _format_schema_context(schema_data: Dict[str, Any], format_type: str) -> str:\n        \"\"\"Format schema data into context string.\"\"\"\n        try:\n            if format_type == \"json\":\n                return json.dumps(schema_data, indent=2)\n            \n            context_parts = []\n            \n            if format_type == \"summary\":\n                context_parts.append(f\"Database Schema (scanned: {schema_data.get('scan_time', 'unknown')}):\")\n                context_parts.append(f\"DocTypes: {schema_data['summary']['total_doctypes']}\")\n                context_parts.append(f\"Custom DocTypes: {schema_data['summary']['custom_doctypes']}\")\n                context_parts.append(f\"Database Tables: {schema_data['summary']['total_tables']}\")\n                \n                # Key DocTypes summary\n                context_parts.append(\"\\nKey DocTypes:\")\n                for name, info in list(schema_data['doctypes'].items())[:10]:\n                    field_count = len(info.get('fields', []))\n                    context_parts.append(f\"- {name}: {field_count} fields\")\n                    \n            else:  # detailed\n                context_parts.append(f\"Detailed Schema (scanned: {schema_data.get('scan_time', 'unknown')}):\")\n                \n                # DocTypes details\n                for name, info in list(schema_data['doctypes'].items())[:20]:\n                    context_parts.append(f\"\\n{name}:\")\n                    context_parts.append(f\"  Module: {info.get('module', 'unknown')}\")\n                    context_parts.append(f\"  Custom: {info.get('is_custom', False)}\")\n                    \n                    # Key fields\n                    key_fields = info.get('fields', [])[:8]\n                    if key_fields:\n                        context_parts.append(\"  Fields:\")\n                        for field in key_fields:\n                            req_marker = \" (required)\" if field.get('reqd') else \"\"\n                            context_parts.append(f\"    {field['fieldname']} ({field['fieldtype']}){req_marker}\")\n            \n            return \"\\n\".join(context_parts)\n            \n        except Exception as e:\n            frappe.log_error(f\"Format schema context error: {str(e)}\", \"Schema Service\")\n            return \"Schema formatting error\"\n    \n    @staticmethod\n    def save_schema_to_settings(schema_data: Dict[str, Any]) -> bool:\n        \"\"\"\n        Save schema data to AI Assistant Settings.\n        \n        Args:\n            schema_data (Dict[str, Any]): Schema data to save\n        \n        Returns:\n            bool: True if saved successfully\n        \"\"\"\n        try:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            \n            # Convert to JSON string (with size limit)\n            schema_json = json.dumps(schema_data)\n            \n            # Limit size to prevent database issues (e.g., 1MB limit)\n            max_size = 1024 * 1024  # 1MB\n            if len(schema_json) > max_size:\n                # Truncate data while keeping structure\n                truncated_data = {\n                    \"scan_time\": schema_data.get(\"scan_time\"),\n                    \"summary\": schema_data.get(\"summary\", {}),\n                    \"doctypes\": dict(list(schema_data.get(\"doctypes\", {}).items())[:50]),\n                    \"tables\": dict(list(schema_data.get(\"tables\", {}).items())[:50]),\n                    \"truncated\": True\n                }\n                schema_json = json.dumps(truncated_data)\n            \n            # Save to settings - assuming we add a Long Text field called 'cached_schema'\n            settings.db_set('cached_schema', schema_json, update_modified=True)\n            settings.db_set('schema_last_scan', now_datetime(), update_modified=True)\n            \n            return True\n            \n        except Exception as e:\n            frappe.log_error(f\"Save schema error: {str(e)}\", \"Schema Service\")\n            return False\n\n\ndef scan_database_background():\n    \"\"\"\n    Background job function for database scanning.\n    This function is called by frappe.enqueue.\n    \"\"\"\n    try:\n        frappe.logger(\"schema_scan\").info(\"Starting background database scan\")\n        \n        # Perform full scan\n        schema_data = SchemaService.scan_database(include_custom=True, max_tables=200)\n        \n        # Save to settings\n        success = SchemaService.save_schema_to_settings(schema_data)\n        \n        if success:\n            frappe.logger(\"schema_scan\").info(f\"Schema scan completed successfully. \"\n                                            f\"Found {schema_data['summary']['total_doctypes']} DocTypes \"\n                                            f\"and {schema_data['summary']['total_tables']} tables.\")\n        else:\n            frappe.logger(\"schema_scan\").error(\"Failed to save schema scan results\")\n            \n    except Exception as e:\n        frappe.log_error(f\"Background schema scan error: {str(e)}\", \"Schema Background Scan\")\n        frappe.logger(\"schema_scan\").error(f\"Background scan failed: {str(e)}\")\n\n\ndef get_schema_service() -> SchemaService:\n    \"\"\"\n    Get SchemaService instance.\n    \n    Returns:\n        SchemaService: Service instance\n    \"\"\"\n    return SchemaService()","size_bytes":18083},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_assistant_settings/__init__.py":{"content":"","size_bytes":0},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_assistant_settings/ai_assistant_settings.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe.model.document import Document\n\n\nclass AIAssistantSettings(Document):\n\tdef validate(self):\n\t\t\"\"\"Validate AI Assistant Settings\"\"\"\n\t\tif not self.ollama_url:\n\t\t\tfrappe.throw(\"Ollama URL is required\")\n\t\t\n\t\tif not self.model:\n\t\t\tfrappe.throw(\"AI Model is required\")\n\t\t\t\n\t\t# Ensure URL format is correct\n\t\tif not self.ollama_url.startswith(('http://', 'https://')):\n\t\t\tself.ollama_url = f\"http://{self.ollama_url}\"","size_bytes":533},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_assistant_settings/test_ai_assistant_settings.py":{"content":"# Copyright (c) 2025, ERPNext and Contributors\n# See license.txt\n\nimport frappe\nimport unittest\n\n\nclass TestAIAssistantSettings(unittest.TestCase):\n\tdef test_validate_required_fields(self):\n\t\t\"\"\"Test that required fields are validated\"\"\"\n\t\tsettings = frappe.new_doc(\"AI Assistant Settings\")\n\t\t\n\t\t# Test validation for required fields\n\t\twith self.assertRaises(frappe.exceptions.ValidationError):\n\t\t\tsettings.insert()\n\t\t\t\n\tdef test_url_format_correction(self):\n\t\t\"\"\"Test that URL format is corrected automatically\"\"\"\n\t\tsettings = frappe.new_doc(\"AI Assistant Settings\")\n\t\tsettings.ollama_url = \"localhost:11434\"\n\t\tsettings.model = \"llama2\"\n\t\tsettings.validate()\n\t\t\n\t\tself.assertTrue(settings.ollama_url.startswith(\"http://\"))","size_bytes":723},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_chat_message/__init__.py":{"content":"","size_bytes":0},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_chat_message/ai_chat_message.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe.model.document import Document\nfrom frappe.utils import now_datetime\n\n\nclass AIChatMessage(Document):\n\tdef before_insert(self):\n\t\t\"\"\"Set default values before inserting\"\"\"\n\t\tif not self.timestamp:\n\t\t\tself.timestamp = now_datetime()\n\t\t\t\n\t\tif not self.user:\n\t\t\tself.user = frappe.session.user\n\t\t\t\n\t\t# Validate role\n\t\tif self.role not in [\"user\", \"assistant\"]:\n\t\t\tfrappe.throw(\"Role must be either 'user' or 'assistant'\")\n\t\n\tdef after_insert(self):\n\t\t\"\"\"Update session message count after inserting new message\"\"\"\n\t\tif self.session:\n\t\t\tsession_doc = frappe.get_doc(\"AI Chat Session\", self.session)\n\t\t\tsession_doc.update_message_count()\n\t\n\tdef on_trash(self):\n\t\t\"\"\"Update session message count after deleting message\"\"\"\n\t\tif self.session:\n\t\t\tsession_doc = frappe.get_doc(\"AI Chat Session\", self.session)\n\t\t\tsession_doc.update_message_count()","size_bytes":961},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_chat_message/test_ai_chat_message.py":{"content":"# Copyright (c) 2025, ERPNext and Contributors\n# See license.txt\n\nimport frappe\nimport unittest\n\n\nclass TestAIChatMessage(unittest.TestCase):\n\tdef test_message_creation(self):\n\t\t\"\"\"Test that chat message is created with proper defaults\"\"\"\n\t\t# First create a session\n\t\tsession = frappe.new_doc(\"AI Chat Session\")\n\t\tsession.title = \"Test Session\"\n\t\tsession.user = \"Administrator\"\n\t\tsession.insert()\n\t\t\n\t\t# Create a message\n\t\tmessage = frappe.new_doc(\"AI Chat Message\")\n\t\tmessage.session = session.name\n\t\tmessage.content = \"Test message\"\n\t\tmessage.role = \"user\"\n\t\tmessage.insert()\n\t\t\n\t\tself.assertIsNotNone(message.timestamp)\n\t\tself.assertEqual(message.user, \"Administrator\")\n\t\t\n\t\t# Clean up\n\t\tmessage.delete()\n\t\tsession.delete()\n\t\t\n\tdef test_role_validation(self):\n\t\t\"\"\"Test that role validation works correctly\"\"\"\n\t\tmessage = frappe.new_doc(\"AI Chat Message\")\n\t\tmessage.content = \"Test message\"\n\t\tmessage.role = \"invalid_role\"\n\t\t\n\t\twith self.assertRaises(frappe.exceptions.ValidationError):\n\t\t\tmessage.insert()","size_bytes":1009},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_chat_session/__init__.py":{"content":"","size_bytes":0},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_chat_session/ai_chat_session.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe.model.document import Document\nfrom frappe.utils import now_datetime\n\n\nclass AIChatSession(Document):\n\tdef before_insert(self):\n\t\t\"\"\"Set session start time before inserting\"\"\"\n\t\tif not self.session_start:\n\t\t\tself.session_start = now_datetime()\n\t\t\t\n\t\tif not self.user:\n\t\t\tself.user = frappe.session.user\n\t\t\t\n\t\tif not self.title:\n\t\t\tself.title = f\"Chat Session - {frappe.format(self.session_start, 'datetime')}\"\n\t\n\tdef on_update(self):\n\t\t\"\"\"Update message count when session is updated\"\"\"\n\t\tself.update_message_count()\n\t\n\tdef update_message_count(self):\n\t\t\"\"\"Update the message count for this session\"\"\"\n\t\tmessage_count = frappe.db.count(\"AI Chat Message\", {\"session\": self.name})\n\t\tif message_count != self.message_count:\n\t\t\tfrappe.db.set_value(\"AI Chat Session\", self.name, \"message_count\", message_count)\n\t\n\tdef end_session(self):\n\t\t\"\"\"End the current session\"\"\"\n\t\tself.session_end = now_datetime()\n\t\tself.status = \"Completed\"\n\t\tself.save()","size_bytes":1065},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/doctype/ai_chat_session/test_ai_chat_session.py":{"content":"# Copyright (c) 2025, ERPNext and Contributors\n# See license.txt\n\nimport frappe\nimport unittest\nfrom frappe.utils import now_datetime\n\n\nclass TestAIChatSession(unittest.TestCase):\n\tdef test_session_creation(self):\n\t\t\"\"\"Test that chat session is created with proper defaults\"\"\"\n\t\tsession = frappe.new_doc(\"AI Chat Session\")\n\t\tsession.title = \"Test Session\"\n\t\tsession.user = \"Administrator\"\n\t\tsession.insert()\n\t\t\n\t\tself.assertIsNotNone(session.session_start)\n\t\tself.assertEqual(session.status, \"Active\")\n\t\tself.assertEqual(session.message_count, 0)\n\t\t\n\t\t# Clean up\n\t\tsession.delete()\n\t\t\n\tdef test_message_count_update(self):\n\t\t\"\"\"Test that message count is updated correctly\"\"\"\n\t\tsession = frappe.new_doc(\"AI Chat Session\")\n\t\tsession.title = \"Test Session\"\n\t\tsession.user = \"Administrator\"\n\t\tsession.insert()\n\t\t\n\t\t# Create a message\n\t\tmessage = frappe.new_doc(\"AI Chat Message\")\n\t\tmessage.session = session.name\n\t\tmessage.content = \"Test message\"\n\t\tmessage.role = \"user\"\n\t\tmessage.user = \"Administrator\"\n\t\tmessage.insert()\n\t\t\n\t\t# Check if session message count is updated\n\t\tsession.reload()\n\t\tself.assertEqual(session.message_count, 1)\n\t\t\n\t\t# Clean up\n\t\tmessage.delete()\n\t\tsession.delete()","size_bytes":1187},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/page/ai_assistant/__init__.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt","size_bytes":96},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/page/ai_assistant/ai_assistant.css":{"content":"/* AI Assistant Page Styles */\n/* Using ERPNext design system variables and patterns */\n\n.ai-assistant-page {\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    background-color: var(--bg-color);\n}\n\n.ai-assistant-page .page-head {\n    background: var(--navbar-bg);\n    border-bottom: 1px solid var(--border-color);\n    padding: 15px 0;\n    flex-shrink: 0;\n}\n\n.ai-assistant-page .page-head .page-title h1 {\n    margin: 0;\n    color: var(--text-color);\n    font-size: 24px;\n    font-weight: 600;\n}\n\n.ai-assistant-page .page-head .page-title p {\n    margin: 5px 0 0 0;\n    color: var(--text-muted);\n    font-size: 14px;\n}\n\n.ai-assistant-page .page-actions {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n}\n\n.ai-assistant-page .page-body {\n    flex: 1;\n    padding: 20px 0;\n    overflow: hidden;\n}\n\n/* Chat Container */\n.chat-container {\n    height: calc(100vh - 160px);\n    display: flex;\n    flex-direction: column;\n    background: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    box-shadow: var(--shadow-sm);\n}\n\n.chat-header {\n    padding: 15px 20px;\n    border-bottom: 1px solid var(--border-color);\n    background: var(--control-bg);\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-shrink: 0;\n}\n\n.session-info .session-title {\n    font-weight: 600;\n    color: var(--text-color);\n    font-size: 16px;\n}\n\n.session-info .session-status {\n    display: flex;\n    align-items: center;\n    gap: 5px;\n    margin-top: 4px;\n    font-size: 12px;\n    color: var(--text-muted);\n}\n\n/* Messages Area */\n.chat-messages {\n    flex: 1;\n    overflow-y: auto;\n    padding: 20px;\n    display: flex;\n    flex-direction: column;\n    gap: 16px;\n    scroll-behavior: smooth;\n}\n\n.chat-messages::-webkit-scrollbar {\n    width: 6px;\n}\n\n.chat-messages::-webkit-scrollbar-track {\n    background: var(--scrollbar-track-color);\n}\n\n.chat-messages::-webkit-scrollbar-thumb {\n    background: var(--scrollbar-thumb-color);\n    border-radius: 3px;\n}\n\n/* Welcome Message */\n.welcome-message {\n    display: flex;\n    gap: 12px;\n    padding: 20px;\n    background: linear-gradient(135deg, var(--primary-color-light), var(--primary-color));\n    border-radius: var(--border-radius-md);\n    color: white;\n    margin-bottom: 20px;\n}\n\n.welcome-message .assistant-avatar {\n    width: 40px;\n    height: 40px;\n    background: rgba(255, 255, 255, 0.2);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-shrink: 0;\n}\n\n.welcome-message .message-content h4 {\n    margin: 0 0 8px 0;\n    font-size: 18px;\n    font-weight: 600;\n}\n\n.welcome-message .message-content p {\n    margin: 0;\n    opacity: 0.9;\n    line-height: 1.5;\n}\n\n/* Chat Messages */\n.message {\n    display: flex;\n    gap: 12px;\n    margin-bottom: 16px;\n    animation: fadeInUp 0.3s ease;\n}\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.message.user-message {\n    flex-direction: row-reverse;\n}\n\n.user-avatar, .assistant-avatar {\n    width: 36px;\n    height: 36px;\n    border-radius: 50%;\n    flex-shrink: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.user-avatar img {\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    object-fit: cover;\n}\n\n.assistant-avatar {\n    background: var(--primary-color);\n    color: white;\n}\n\n.message-content {\n    max-width: 70%;\n    position: relative;\n}\n\n.message-text {\n    background: var(--control-bg);\n    padding: 12px 16px;\n    border-radius: var(--border-radius-md);\n    line-height: 1.5;\n    word-wrap: break-word;\n}\n\n.user-message .message-text {\n    background: var(--primary-color);\n    color: white;\n    border-bottom-right-radius: 4px;\n}\n\n.assistant-message .message-text {\n    border-bottom-left-radius: 4px;\n}\n\n.message-text pre {\n    background: var(--bg-color);\n    padding: 12px;\n    border-radius: var(--border-radius);\n    margin: 8px 0;\n    overflow-x: auto;\n    font-size: 13px;\n}\n\n.message-text code {\n    background: var(--bg-color);\n    padding: 2px 6px;\n    border-radius: 3px;\n    font-size: 13px;\n}\n\n.message-time {\n    font-size: 11px;\n    color: var(--text-muted);\n    margin-top: 4px;\n    text-align: right;\n}\n\n.user-message .message-time {\n    text-align: left;\n}\n\n.error-message .message-text {\n    background: var(--red-100);\n    border-left: 3px solid var(--red-500);\n    color: var(--red-700);\n}\n\n/* Typing Indicator */\n.typing-indicator {\n    display: flex;\n    gap: 12px;\n    margin-bottom: 16px;\n}\n\n.typing-dots {\n    background: var(--control-bg);\n    padding: 12px 16px;\n    border-radius: var(--border-radius-md);\n    border-bottom-left-radius: 4px;\n    display: flex;\n    gap: 4px;\n    align-items: center;\n}\n\n.typing-dots span {\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: var(--text-muted);\n    animation: typing 1.4s infinite ease-in-out;\n}\n\n.typing-dots span:nth-child(2) {\n    animation-delay: 0.2s;\n}\n\n.typing-dots span:nth-child(3) {\n    animation-delay: 0.4s;\n}\n\n@keyframes typing {\n    0%, 80%, 100% {\n        opacity: 0.3;\n        transform: scale(0.8);\n    }\n    40% {\n        opacity: 1;\n        transform: scale(1);\n    }\n}\n\n/* Chat Input */\n.chat-input-container {\n    padding: 20px;\n    border-top: 1px solid var(--border-color);\n    background: var(--control-bg);\n    flex-shrink: 0;\n}\n\n.chat-input-container .input-group {\n    position: relative;\n}\n\n.chat-input-container textarea {\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-md);\n    padding: 12px 16px;\n    resize: none;\n    font-family: var(--font-family);\n    line-height: 1.4;\n    max-height: 120px;\n    min-height: 44px;\n}\n\n.chat-input-container textarea:focus {\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 2px var(--primary-color-light);\n}\n\n.chat-input-container .input-group-btn {\n    position: absolute;\n    right: 8px;\n    bottom: 8px;\n}\n\n.chat-input-container .input-group-btn .btn {\n    border-radius: 50%;\n    width: 36px;\n    height: 36px;\n    padding: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.input-footer {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    margin-top: 8px;\n    font-size: 12px;\n}\n\n.char-count {\n    color: var(--text-muted);\n}\n\n.char-count.text-warning {\n    color: var(--orange-500);\n}\n\n.char-count.text-danger {\n    color: var(--red-500);\n}\n\n/* Sidebar */\n.sidebar {\n    height: calc(100vh - 160px);\n    overflow-y: auto;\n    padding-left: 20px;\n}\n\n.sidebar-section {\n    margin-bottom: 30px;\n}\n\n.sidebar-section h5 {\n    margin: 0 0 15px 0;\n    font-size: 14px;\n    font-weight: 600;\n    color: var(--text-color);\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n/* Session List */\n.session-list {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n.session-item {\n    padding: 12px 16px;\n    background: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.session-item:hover {\n    background: var(--control-bg);\n    border-color: var(--primary-color-light);\n}\n\n.session-item.active {\n    background: var(--primary-color-light);\n    border-color: var(--primary-color);\n    color: var(--primary-color-dark);\n}\n\n.session-item .session-title {\n    font-weight: 500;\n    font-size: 13px;\n    margin-bottom: 4px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n\n.session-item .session-meta {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    font-size: 11px;\n}\n\n.no-sessions {\n    padding: 30px 15px;\n    text-align: center;\n    color: var(--text-muted);\n    font-style: italic;\n}\n\n/* Quick Actions */\n.quick-actions {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n.quick-action {\n    text-align: left;\n    padding: 8px 12px;\n    font-size: 13px;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    border: 1px solid var(--border-color);\n    transition: all 0.2s ease;\n}\n\n.quick-action:hover {\n    background: var(--control-bg);\n    border-color: var(--primary-color-light);\n}\n\n.quick-action i {\n    width: 16px;\n    text-align: center;\n    opacity: 0.7;\n}\n\n/* Status Panel */\n.status-panel {\n    background: var(--card-bg);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    padding: 16px;\n}\n\n.status-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 6px 0;\n    font-size: 13px;\n}\n\n.status-item:not(:last-child) {\n    border-bottom: 1px solid var(--border-color);\n}\n\n.status-item label {\n    color: var(--text-muted);\n    font-weight: 500;\n    margin: 0;\n}\n\n.status-value {\n    display: flex;\n    align-items: center;\n    gap: 6px;\n    font-weight: 500;\n}\n\n/* Modal Customizations */\n.modal-content {\n    border-radius: var(--border-radius-lg);\n    box-shadow: var(--shadow-lg);\n}\n\n.modal-header {\n    border-bottom: 1px solid var(--border-color);\n    background: var(--control-bg);\n}\n\n.modal-title {\n    font-weight: 600;\n    color: var(--text-color);\n}\n\n.command-preview {\n    background: var(--bg-color);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius);\n    padding: 12px;\n    font-size: 13px;\n    max-height: 200px;\n    overflow-y: auto;\n    word-wrap: break-word;\n}\n\n.command-description {\n    color: var(--text-color);\n    font-weight: 500;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .ai-assistant-page .page-head .row {\n        flex-direction: column;\n        gap: 15px;\n    }\n    \n    .ai-assistant-page .page-actions {\n        justify-content: center;\n    }\n    \n    .chat-container {\n        height: calc(100vh - 200px);\n    }\n    \n    .sidebar {\n        height: auto;\n        margin-top: 20px;\n        padding-left: 0;\n    }\n    \n    .message-content {\n        max-width: 85%;\n    }\n    \n    .chat-input-container {\n        padding: 15px;\n    }\n}\n\n@media (max-width: 576px) {\n    .ai-assistant-page .page-head {\n        padding: 10px 0;\n    }\n    \n    .chat-messages {\n        padding: 15px;\n        gap: 12px;\n    }\n    \n    .message-content {\n        max-width: 90%;\n    }\n    \n    .welcome-message {\n        padding: 15px;\n        margin-bottom: 15px;\n    }\n    \n    .sidebar-section {\n        margin-bottom: 20px;\n    }\n}\n\n/* Indicators */\n.indicator {\n    display: inline-block;\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    background: var(--gray-500);\n}\n\n.indicator.green {\n    background: var(--green-500);\n}\n\n.indicator.red {\n    background: var(--red-500);\n}\n\n.indicator.orange {\n    background: var(--orange-500);\n}\n\n.indicator.grey {\n    background: var(--gray-400);\n}\n\n/* Loading states */\n.loading {\n    opacity: 0.6;\n    pointer-events: none;\n}\n\n.loading::after {\n    content: \"\";\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 20px;\n    height: 20px;\n    margin: -10px 0 0 -10px;\n    border: 2px solid var(--border-color);\n    border-top: 2px solid var(--primary-color);\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}","size_bytes":11347},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/page/ai_assistant/ai_assistant.js":{"content":"// Copyright (c) 2025, ERPNext and contributors\n// For license information, please see license.txt\n\nfrappe.pages['ai_assistant'].on_page_load = function(wrapper) {\n    var page = frappe.ui.make_app_page({\n        parent: wrapper,\n        title: __('AI Assistant'),\n        single_column: true\n    });\n\n    // Initialize the AI Assistant interface\n    new AIAssistantInterface(page);\n};\n\nclass AIAssistantInterface {\n    constructor(page) {\n        this.page = page;\n        this.wrapper = page.wrapper;\n        this.current_session_id = null;\n        this.user_data = null;\n        this.settings = {};\n        this.permissions = {};\n        this.pending_command = null;\n        \n        this.setup_page();\n        this.init_realtime();\n        this.load_initial_data();\n    }\n\n    setup_page() {\n        // Set up the main page layout\n        $(this.wrapper).find('.layout-main-section').html(frappe.render_template('ai_assistant', {}));\n        \n        this.setup_elements();\n        this.setup_event_handlers();\n        this.setup_auto_resize();\n    }\n\n    setup_elements() {\n        // Cache frequently used elements\n        this.$chat_messages = $('#chat-messages');\n        this.$chat_input = $('#chat-input');\n        this.$send_button = $('#send-button');\n        this.$session_list = $('#session-list');\n        this.$typing_indicator = $('#typing-indicator');\n        this.$char_count = $('#char-count');\n    }\n\n    setup_event_handlers() {\n        const self = this;\n\n        // Chat input handlers\n        this.$chat_input.on('input', () => this.handle_input_change());\n        this.$chat_input.on('keydown', (e) => this.handle_keydown(e));\n\n        // Button handlers\n        this.$send_button.on('click', () => this.send_message());\n        $('#new-session').on('click', () => this.create_new_session());\n        $('#clear-history').on('click', () => this.confirm_clear_history());\n        $('#toggle-settings').on('click', () => this.show_settings_modal());\n\n        // Settings modal handlers\n        $('#save-settings').on('click', () => this.save_settings());\n\n        // Command confirmation handlers\n        $('#confirm-command').on('click', () => this.execute_confirmed_command());\n\n        // Quick action handlers\n        $('.quick-action').on('click', function() {\n            const query = $(this).data('query');\n            self.$chat_input.val(query);\n            self.handle_input_change();\n            self.send_message();\n        });\n\n        // Session list handlers\n        this.$session_list.on('click', '.session-item', function() {\n            const sessionId = $(this).data('session-id');\n            self.load_session(sessionId);\n        });\n    }\n\n    setup_auto_resize() {\n        // Auto-resize textarea\n        this.$chat_input.on('input', function() {\n            this.style.height = 'auto';\n            this.style.height = Math.min(this.scrollHeight, 120) + 'px';\n        });\n    }\n\n    init_realtime() {\n        // Set up realtime updates for chat messages\n        if (frappe.realtime) {\n            frappe.realtime.on('ai_assistant_message', (data) => {\n                if (data.session_id === this.current_session_id) {\n                    this.handle_realtime_message(data);\n                }\n            });\n\n            frappe.realtime.on('ai_assistant_status', (data) => {\n                this.update_status_panel(data);\n            });\n        }\n    }\n\n    load_initial_data() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.page.ai_assistant.ai_assistant.get_page_data',\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.user_data = r.message.user;\n                    this.settings = r.message.settings;\n                    this.permissions = r.message.permissions;\n                    this.update_ui();\n                    this.load_recent_sessions();\n                    this.check_ai_status();\n                } else {\n                    frappe.msgprint(__('Failed to load page data'));\n                }\n            },\n            error: () => {\n                frappe.msgprint(__('Error loading AI Assistant'));\n            }\n        });\n    }\n\n    update_ui() {\n        // Update status panel\n        $('#current-model').text(this.settings.model || 'Unknown');\n        $('#safe-mode-status').html(\n            this.settings.safe_mode ? \n            '<i class=\"indicator green\"></i> Enabled' : \n            '<i class=\"indicator red\"></i> Disabled'\n        );\n\n        // Hide settings button if no permission\n        if (!this.permissions.can_manage_settings) {\n            $('#toggle-settings').hide();\n        }\n\n        // Disable input if no permission to send messages\n        if (!this.permissions.can_send_messages) {\n            this.$chat_input.prop('disabled', true);\n            this.$send_button.prop('disabled', true);\n        }\n    }\n\n    handle_input_change() {\n        const text = this.$chat_input.val().trim();\n        const charCount = text.length;\n        \n        this.$char_count.text(`${charCount}/2000`);\n        this.$send_button.prop('disabled', !text || charCount > 2000);\n        \n        if (charCount > 1900) {\n            this.$char_count.addClass('text-warning');\n        } else if (charCount > 2000) {\n            this.$char_count.addClass('text-danger');\n        } else {\n            this.$char_count.removeClass('text-warning text-danger');\n        }\n    }\n\n    handle_keydown(e) {\n        if (e.key === 'Enter') {\n            if (e.shiftKey) {\n                // Allow new line with Shift+Enter\n                return true;\n            } else {\n                // Send message with Enter\n                e.preventDefault();\n                if (!this.$send_button.prop('disabled')) {\n                    this.send_message();\n                }\n            }\n        }\n    }\n\n    send_message() {\n        const message = this.$chat_input.val().trim();\n        if (!message) return;\n\n        // Clear input and disable button\n        this.$chat_input.val('').trigger('input');\n        this.handle_input_change();\n\n        // Add user message to chat\n        this.add_message('user', message);\n\n        // Show typing indicator\n        this.show_typing_indicator();\n\n        // Send to backend\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.send_message',\n            args: {\n                session_id: this.current_session_id,\n                message: message,\n                role: 'user'\n            },\n            callback: (r) => {\n                this.hide_typing_indicator();\n                \n                if (r.message && r.message.success) {\n                    this.current_session_id = r.message.session_id;\n                    \n                    // Add AI response\n                    this.add_message('assistant', r.message.ai_response);\n\n                    // Handle command analysis\n                    if (r.message.command_analysis && r.message.command_analysis.command) {\n                        this.handle_command_analysis(r.message.command_analysis, r.message.assistant_message_id);\n                    }\n\n                    // Update session title if needed\n                    this.update_session_title();\n                } else {\n                    this.add_message('assistant', r.message?.error || __('Sorry, I encountered an error processing your request.'), true);\n                }\n            },\n            error: () => {\n                this.hide_typing_indicator();\n                this.add_message('assistant', __('Connection error. Please try again.'), true);\n            }\n        });\n    }\n\n    add_message(role, content, is_error = false) {\n        const messageClass = role === 'user' ? 'user-message' : 'assistant-message';\n        const errorClass = is_error ? 'error-message' : '';\n        \n        const avatar = role === 'user' ? \n            `<img src=\"${this.user_data?.image || '/assets/frappe/images/default-avatar.png'}\" class=\"user-avatar\">` :\n            '<div class=\"assistant-avatar\"><i class=\"fa fa-robot\"></i></div>';\n\n        const messageHtml = `\n            <div class=\"message ${messageClass} ${errorClass}\">\n                ${avatar}\n                <div class=\"message-content\">\n                    <div class=\"message-text\">${this.format_message_content(content)}</div>\n                    <div class=\"message-time\">${moment().format('HH:mm')}</div>\n                </div>\n            </div>\n        `;\n\n        this.$chat_messages.append(messageHtml);\n        this.scroll_to_bottom();\n    }\n\n    format_message_content(content) {\n        // Basic formatting for message content\n        return content\n            .replace(/\\n/g, '<br>')\n            .replace(/```(\\w+)?\\n?([\\s\\S]*?)```/g, '<pre><code>$2</code></pre>')\n            .replace(/`([^`]+)`/g, '<code>$1</code>');\n    }\n\n    show_typing_indicator() {\n        this.$typing_indicator.show();\n        this.scroll_to_bottom();\n    }\n\n    hide_typing_indicator() {\n        this.$typing_indicator.hide();\n    }\n\n    scroll_to_bottom() {\n        const chatContainer = this.$chat_messages[0];\n        chatContainer.scrollTop = chatContainer.scrollHeight;\n    }\n\n    handle_command_analysis(analysis, message_id) {\n        if (analysis.isDestructive && this.settings.confirm_destructive) {\n            // Show confirmation modal for destructive commands\n            this.pending_command = {\n                command: analysis.command,\n                description: analysis.description,\n                message_id: message_id\n            };\n            this.show_command_confirmation_modal(analysis);\n        } else if (analysis.command && analysis.category !== 'other') {\n            // Auto-execute non-destructive commands\n            this.execute_command(analysis.command, message_id);\n        }\n    }\n\n    show_command_confirmation_modal(analysis) {\n        $('#command-preview').text(analysis.command);\n        $('#command-description').text(analysis.description);\n        $('#command-modal').modal('show');\n    }\n\n    execute_confirmed_command() {\n        if (this.pending_command) {\n            $('#command-modal').modal('hide');\n            this.execute_command(this.pending_command.command, this.pending_command.message_id);\n            this.pending_command = null;\n        }\n    }\n\n    execute_command(command, message_id) {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.confirm_execute',\n            args: {\n                message_id: message_id,\n                command: command\n            },\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.add_message('assistant', \n                        `Command executed successfully:\\n\\`\\`\\`\\n${JSON.stringify(r.message.result, null, 2)}\\n\\`\\`\\``);\n                } else {\n                    this.add_message('assistant', \n                        `Command execution failed: ${r.message?.error || 'Unknown error'}`, true);\n                }\n            }\n        });\n    }\n\n    create_new_session() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.page.ai_assistant.ai_assistant.initialize_session',\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.current_session_id = r.message.session.id;\n                    this.$chat_messages.find('.message').remove();\n                    this.show_welcome_message();\n                    this.load_recent_sessions();\n                    frappe.show_alert({message: __('New session created'), indicator: 'green'});\n                } else {\n                    frappe.msgprint(__('Failed to create new session'));\n                }\n            }\n        });\n    }\n\n    show_welcome_message() {\n        // The welcome message is already in the HTML template\n        $('.welcome-message').show();\n    }\n\n    confirm_clear_history() {\n        frappe.confirm(\n            __('Are you sure you want to clear all chat history? This action cannot be undone.'),\n            () => {\n                this.clear_history();\n            }\n        );\n    }\n\n    clear_history() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.clear_history',\n            args: {\n                session_id: this.current_session_id\n            },\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.$chat_messages.find('.message').remove();\n                    this.show_welcome_message();\n                    this.current_session_id = null;\n                    this.load_recent_sessions();\n                    frappe.show_alert({message: __('History cleared'), indicator: 'green'});\n                } else {\n                    frappe.msgprint(__('Failed to clear history'));\n                }\n            }\n        });\n    }\n\n    show_settings_modal() {\n        // Populate current settings\n        $('#ollama-url').val(this.settings.ollama_url);\n        $('#ai-model').val(this.settings.model);\n        $('#safe-mode').prop('checked', this.settings.safe_mode);\n        $('#confirm-destructive').prop('checked', this.settings.confirm_destructive);\n        $('#log-commands').prop('checked', this.settings.log_commands);\n        \n        $('#settings-modal').modal('show');\n    }\n\n    save_settings() {\n        const settings = {\n            ollama_url: $('#ollama-url').val(),\n            model: $('#ai-model').val(),\n            safe_mode: $('#safe-mode').prop('checked'),\n            confirm_destructive: $('#confirm-destructive').prop('checked'),\n            log_commands: $('#log-commands').prop('checked')\n        };\n\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.update_settings',\n            args: settings,\n            callback: (r) => {\n                if (r.message) {\n                    this.settings = r.message;\n                    this.update_ui();\n                    $('#settings-modal').modal('hide');\n                    frappe.show_alert({message: __('Settings saved'), indicator: 'green'});\n                    this.check_ai_status();\n                } else {\n                    frappe.msgprint(__('Failed to save settings'));\n                }\n            }\n        });\n    }\n\n    load_recent_sessions() {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.get_chat_sessions',\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.render_session_list(r.message.sessions);\n                }\n            }\n        });\n    }\n\n    render_session_list(sessions) {\n        if (!sessions || sessions.length === 0) {\n            this.$session_list.html('<div class=\"no-sessions text-muted text-center\"><p>' + __('No recent sessions') + '</p></div>');\n            return;\n        }\n\n        let html = '';\n        sessions.forEach(session => {\n            const isActive = session.name === this.current_session_id ? 'active' : '';\n            const statusIcon = session.status === 'Active' ? 'green' : 'grey';\n            \n            html += `\n                <div class=\"session-item ${isActive}\" data-session-id=\"${session.name}\">\n                    <div class=\"session-title\">${session.title}</div>\n                    <div class=\"session-meta\">\n                        <small class=\"text-muted\">${moment(session.session_start).fromNow()}</small>\n                        <span class=\"indicator ${statusIcon}\"></span>\n                    </div>\n                </div>\n            `;\n        });\n\n        this.$session_list.html(html);\n    }\n\n    load_session(session_id) {\n        frappe.call({\n            method: 'ai_assistant.ai_assistant.api.get_chat_messages',\n            args: {\n                session_id: session_id\n            },\n            callback: (r) => {\n                if (r.message && r.message.success) {\n                    this.current_session_id = session_id;\n                    this.render_chat_messages(r.message.messages);\n                    this.update_session_title();\n                } else {\n                    frappe.msgprint(__('Failed to load session'));\n                }\n            }\n        });\n    }\n\n    render_chat_messages(messages) {\n        this.$chat_messages.find('.message').remove();\n        \n        if (!messages || messages.length === 0) {\n            this.show_welcome_message();\n            return;\n        }\n\n        messages.forEach(message => {\n            this.add_message(message.role, message.content, message.is_error);\n        });\n    }\n\n    update_session_title() {\n        if (this.current_session_id) {\n            const sessionItem = $(`.session-item[data-session-id=\"${this.current_session_id}\"]`);\n            if (sessionItem.length) {\n                const title = sessionItem.find('.session-title').text();\n                $('#current-session-title').text(title);\n                $('.session-item').removeClass('active');\n                sessionItem.addClass('active');\n            }\n        }\n    }\n\n    check_ai_status() {\n        // Simple status check - in a real implementation, you might have a dedicated endpoint\n        $('#ai-status').html('<i class=\"indicator orange\"></i> ' + __('Checking...'));\n        \n        // Simulate status check\n        setTimeout(() => {\n            $('#ai-status').html('<i class=\"indicator green\"></i> ' + __('Connected'));\n        }, 1000);\n    }\n\n    handle_realtime_message(data) {\n        // Handle real-time message updates\n        if (data.type === 'message') {\n            this.add_message(data.role, data.content);\n        } else if (data.type === 'typing') {\n            if (data.typing) {\n                this.show_typing_indicator();\n            } else {\n                this.hide_typing_indicator();\n            }\n        }\n    }\n\n    update_status_panel(data) {\n        // Update status panel with real-time data\n        if (data.ai_status) {\n            $('#ai-status').html(`<i class=\"indicator ${data.ai_status.connected ? 'green' : 'red'}\"></i> ${data.ai_status.status}`);\n        }\n    }\n}","size_bytes":18079},"attached_assets/BenchChatAI/ai_assistant/ai_assistant/page/ai_assistant/ai_assistant.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport frappe\nfrom frappe import _\nfrom frappe.utils import now_datetime\n\n\nclass AIAssistantPage:\n    \"\"\"\n    Server-side page controller for AI Assistant Desk page.\n    \n    Handles page configuration, permissions, and initialization.\n    \"\"\"\n    \n    def __init__(self):\n        self.page_name = \"ai_assistant\"\n        self.page_title = _(\"AI Assistant\")\n        self.icon = \"fa fa-robot\"\n        \n    def get_context(self):\n        \"\"\"\n        Get page context and configuration.\n        \n        Returns:\n            dict: Page context with configuration and initial data\n        \"\"\"\n        # Check permissions\n        self.check_permission()\n        \n        context = frappe._dict()\n        context.page_title = self.page_title\n        context.icon = self.icon\n        context.user = frappe.session.user\n        context.user_image = frappe.db.get_value(\"User\", frappe.session.user, \"user_image\")\n        context.full_name = frappe.utils.get_fullname(frappe.session.user)\n        \n        # Get current settings\n        try:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            context.settings = {\n                \"ollama_url\": settings.ollama_url or \"http://localhost:11434\",\n                \"model\": settings.model or \"llama2\",\n                \"safe_mode\": settings.safe_mode,\n                \"confirm_destructive\": settings.confirm_destructive,\n                \"log_commands\": settings.log_commands\n            }\n        except Exception:\n            # Provide defaults if settings not found\n            context.settings = {\n                \"ollama_url\": \"http://localhost:11434\",\n                \"model\": \"llama2\", \n                \"safe_mode\": 1,\n                \"confirm_destructive\": 1,\n                \"log_commands\": 0\n            }\n        \n        # Get recent chat sessions for the user\n        try:\n            context.recent_sessions = frappe.get_all(\"AI Chat Session\",\n                filters={\"user\": frappe.session.user, \"status\": \"Active\"},\n                fields=[\"name\", \"title\", \"session_start\", \"message_count\"],\n                order_by=\"session_start desc\",\n                limit=10\n            )\n        except Exception:\n            context.recent_sessions = []\n        \n        # Check user permissions\n        context.can_manage_settings = frappe.has_permission(\"AI Assistant Settings\", \"write\")\n        context.can_create_sessions = frappe.has_permission(\"AI Chat Session\", \"create\")\n        context.can_send_messages = frappe.has_permission(\"AI Chat Message\", \"create\")\n        \n        return context\n    \n    def check_permission(self):\n        \"\"\"\n        Check if user has permission to access the AI Assistant page.\n        \n        Raises:\n            frappe.PermissionError: If user doesn't have required permissions\n        \"\"\"\n        if frappe.session.user == \"Guest\":\n            frappe.throw(_(\"Please log in to access AI Assistant\"), frappe.AuthenticationError)\n        \n        # Check if user can at least read AI Chat Sessions or Messages\n        if not (frappe.has_permission(\"AI Chat Session\", \"read\") or \n                frappe.has_permission(\"AI Chat Message\", \"read\")):\n            frappe.throw(_(\"You don't have permission to access AI Assistant\"), \n                        frappe.PermissionError)\n    \n    @staticmethod\n    def get_page_info():\n        \"\"\"\n        Get static page information for registration.\n        \n        Returns:\n            dict: Page registration info\n        \"\"\"\n        return {\n            \"page_name\": \"ai_assistant\",\n            \"page_title\": _(\"AI Assistant\"),\n            \"icon\": \"fa fa-robot\",\n            \"single_page\": True,\n            \"is_query_report\": False\n        }\n\n\ndef get_context(context=None):\n    \"\"\"\n    ERPNext page context handler.\n    \n    Args:\n        context (dict, optional): Existing context\n        \n    Returns:\n        dict: Complete page context\n    \"\"\"\n    page = AIAssistantPage()\n    return page.get_context()\n\n\n@frappe.whitelist()\ndef get_page_data():\n    \"\"\"\n    Get page data for JavaScript initialization.\n    \n    Returns:\n        dict: Page data including user info and permissions\n    \"\"\"\n    try:\n        page = AIAssistantPage()\n        page.check_permission()\n        \n        # Get settings\n        try:\n            settings = frappe.get_single(\"AI Assistant Settings\")\n            settings_data = {\n                \"ollama_url\": settings.ollama_url or \"http://localhost:11434\",\n                \"model\": settings.model or \"llama2\",\n                \"safe_mode\": settings.safe_mode,\n                \"confirm_destructive\": settings.confirm_destructive,\n                \"log_commands\": settings.log_commands\n            }\n        except Exception:\n            settings_data = {\n                \"ollama_url\": \"http://localhost:11434\",\n                \"model\": \"llama2\",\n                \"safe_mode\": 1,\n                \"confirm_destructive\": 1,\n                \"log_commands\": 0\n            }\n        \n        return {\n            \"success\": True,\n            \"user\": {\n                \"name\": frappe.session.user,\n                \"full_name\": frappe.utils.get_fullname(frappe.session.user),\n                \"image\": frappe.db.get_value(\"User\", frappe.session.user, \"user_image\")\n            },\n            \"settings\": settings_data,\n            \"permissions\": {\n                \"can_manage_settings\": frappe.has_permission(\"AI Assistant Settings\", \"write\"),\n                \"can_create_sessions\": frappe.has_permission(\"AI Chat Session\", \"create\"),\n                \"can_send_messages\": frappe.has_permission(\"AI Chat Message\", \"create\"),\n                \"can_execute_commands\": frappe.has_permission(\"AI Chat Message\", \"write\")\n            },\n            \"server_time\": now_datetime()\n        }\n        \n    except frappe.AuthenticationError:\n        frappe.throw(_(\"Authentication required\"))\n    except frappe.PermissionError:\n        frappe.throw(_(\"Access denied\"))\n    except Exception as e:\n        frappe.log_error(f\"Get Page Data Error: {str(e)}\", \"AI Assistant Page\")\n        frappe.throw(_(\"Failed to load page data\"))\n\n\n@frappe.whitelist()\ndef initialize_session():\n    \"\"\"\n    Initialize a new chat session for the current user.\n    \n    Returns:\n        dict: New session information\n    \"\"\"\n    try:\n        page = AIAssistantPage()\n        page.check_permission()\n        \n        if not frappe.has_permission(\"AI Chat Session\", \"create\"):\n            frappe.throw(_(\"Not permitted to create chat sessions\"), frappe.PermissionError)\n        \n        # Create new session\n        session_doc = frappe.get_doc({\n            \"doctype\": \"AI Chat Session\",\n            \"title\": f\"Chat Session - {frappe.format(now_datetime(), 'datetime')}\",\n            \"user\": frappe.session.user,\n            \"session_start\": now_datetime(),\n            \"status\": \"Active\",\n            \"message_count\": 0\n        })\n        session_doc.insert()\n        \n        return {\n            \"success\": True,\n            \"session\": {\n                \"id\": session_doc.name,\n                \"title\": session_doc.title,\n                \"status\": session_doc.status,\n                \"session_start\": session_doc.session_start\n            }\n        }\n        \n    except frappe.PermissionError:\n        raise\n    except Exception as e:\n        frappe.log_error(f\"Initialize Session Error: {str(e)}\", \"AI Assistant Page\")\n        frappe.throw(_(\"Failed to create new session\"))","size_bytes":7511},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"openai>=1.108.0\",\n    \"setuptools>=80.9.0\",\n]\n","size_bytes":193},"test_server.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSimple test server for ERPNext AI Assistant\nTests the core AI functionality without full ERPNext dependencies\n\"\"\"\n\nimport os\nimport json\nfrom flask import Flask, request, jsonify, render_template_string\nfrom typing import Dict, Any\n\n# Import our enhanced AI service\nimport sys\nsys.path.append('ai_assistant/ai_assistant/services')\n\ntry:\n    from ollama import AIService\nexcept ImportError as e:\n    print(f\"Import error: {e}\")\n    # Create a simple fallback\n    class AIService:\n        def __init__(self, *args, **kwargs):\n            self.provider = kwargs.get('provider', 'ollama')\n            \n        def generate_response(self, prompt, schema_context=\"\"):\n            return f\"Echo: {prompt} (using {self.provider})\"\n            \n        def analyze_command(self, prompt, schema_context=\"\"):\n            return {\n                \"isCommand\": False,\n                \"command\": \"\",\n                \"description\": \"Test response\",\n                \"category\": \"other\",\n                \"isDestructive\": False\n            }\n\napp = Flask(__name__)\n\n# Simple HTML template for testing\nHTML_TEMPLATE = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>AI Assistant Test</title>\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }\n        .chat-box { border: 1px solid #ccc; height: 400px; overflow-y: auto; padding: 10px; margin: 10px 0; }\n        .message { margin: 10px 0; padding: 10px; border-radius: 5px; }\n        .user { background-color: #e3f2fd; text-align: right; }\n        .assistant { background-color: #f1f8e9; }\n        input[type=\"text\"] { width: 70%; padding: 10px; }\n        button { padding: 10px 20px; }\n        .settings { background-color: #fff3e0; padding: 10px; margin: 10px 0; border-radius: 5px; }\n    </style>\n</head>\n<body>\n    <h1> AI Assistant Test Server</h1>\n    \n    <div class=\"settings\">\n        <h3>Settings</h3>\n        <label>\n            Provider: \n            <select id=\"provider\">\n                <option value=\"ollama\">Ollama (Local)</option>\n                <option value=\"openai\">OpenAI</option>\n            </select>\n        </label>\n        <label>\n            Model: <input type=\"text\" id=\"model\" value=\"llama2\" placeholder=\"Model name\">\n        </label>\n        <button onclick=\"updateSettings()\">Update Settings</button>\n    </div>\n    \n    <div class=\"chat-box\" id=\"chatBox\">\n        <div class=\"message assistant\">\n            <strong>AI Assistant:</strong> Hello! I'm ready to help you with ERPNext queries. What would you like to know?\n        </div>\n    </div>\n    \n    <div>\n        <input type=\"text\" id=\"messageInput\" placeholder=\"Ask me anything about ERPNext...\" onkeypress=\"if(event.key==='Enter') sendMessage()\">\n        <button onclick=\"sendMessage()\">Send</button>\n    </div>\n\n    <script>\n        function addMessage(sender, message) {\n            const chatBox = document.getElementById('chatBox');\n            const messageDiv = document.createElement('div');\n            messageDiv.className = `message ${sender}`;\n            messageDiv.innerHTML = `<strong>${sender === 'user' ? 'You' : 'AI Assistant'}:</strong> ${message}`;\n            chatBox.appendChild(messageDiv);\n            chatBox.scrollTop = chatBox.scrollHeight;\n        }\n\n        function sendMessage() {\n            const input = document.getElementById('messageInput');\n            const message = input.value.trim();\n            if (!message) return;\n\n            addMessage('user', message);\n            input.value = '';\n\n            // Send to backend\n            fetch('/chat', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ message: message })\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    addMessage('assistant', data.response);\n                    if (data.command_analysis && data.command_analysis.isCommand) {\n                        addMessage('assistant', ` Command detected: ${data.command_analysis.description}`);\n                    }\n                } else {\n                    addMessage('assistant', `Error: ${data.error}`);\n                }\n            })\n            .catch(error => {\n                addMessage('assistant', `Connection error: ${error.message}`);\n            });\n        }\n\n        function updateSettings() {\n            const provider = document.getElementById('provider').value;\n            const model = document.getElementById('model').value;\n            \n            fetch('/settings', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ provider: provider, model: model })\n            })\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    addMessage('assistant', `Settings updated: ${provider} with model ${model}`);\n                } else {\n                    addMessage('assistant', `Settings error: ${data.error}`);\n                }\n            });\n        }\n    </script>\n</body>\n</html>\n\"\"\"\n\n# Global AI service instance\nai_service = None\n\ndef initialize_ai_service(provider=\"ollama\", model=\"llama2\"):\n    \"\"\"Initialize AI service with given provider and model\"\"\"\n    global ai_service\n    try:\n        if provider == \"openai\":\n            ai_service = AIService(\n                provider=\"openai\",\n                model=model if model.startswith('gpt-') else 'gpt-5',\n                openai_api_key=os.environ.get(\"OPENAI_API_KEY\")\n            )\n        else:\n            ai_service = AIService(\n                provider=\"ollama\",\n                url=\"http://localhost:11434\",\n                model=model or \"llama2\"\n            )\n        return True\n    except Exception as e:\n        print(f\"Failed to initialize AI service: {e}\")\n        return False\n\n@app.route('/')\ndef index():\n    \"\"\"Serve the test interface\"\"\"\n    return render_template_string(HTML_TEMPLATE)\n\n@app.route('/chat', methods=['POST'])\ndef chat():\n    \"\"\"Handle chat messages\"\"\"\n    global ai_service\n    \n    try:\n        data = request.json\n        message = data.get('message', '').strip()\n        \n        if not message:\n            return jsonify({\"success\": False, \"error\": \"Empty message\"})\n        \n        # Initialize AI service if not already done\n        if ai_service is None:\n            if not initialize_ai_service():\n                return jsonify({\"success\": False, \"error\": \"AI service not available\"})\n        \n        # Generate response\n        response = ai_service.generate_response(message, \"\")\n        \n        # Analyze if it's a command\n        command_analysis = ai_service.analyze_command(message, \"\")\n        \n        return jsonify({\n            \"success\": True,\n            \"response\": response,\n            \"command_analysis\": command_analysis\n        })\n        \n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)})\n\n@app.route('/settings', methods=['POST'])\ndef update_settings():\n    \"\"\"Update AI service settings\"\"\"\n    try:\n        data = request.json\n        provider = data.get('provider', 'ollama')\n        model = data.get('model', 'llama2')\n        \n        success = initialize_ai_service(provider, model)\n        \n        return jsonify({\n            \"success\": success,\n            \"message\": f\"Settings updated to {provider} with model {model}\" if success else \"Failed to update settings\"\n        })\n        \n    except Exception as e:\n        return jsonify({\"success\": False, \"error\": str(e)})\n\n@app.route('/health')\ndef health():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({\n        \"status\": \"healthy\",\n        \"ai_service\": \"available\" if ai_service else \"not_initialized\"\n    })\n\nif __name__ == '__main__':\n    print(\" Starting AI Assistant Test Server...\")\n    print(\" This is a standalone test server for the ERPNext AI Assistant\")\n    print(\" Open http://localhost:5000 to test the AI functionality\")\n    \n    # Initialize with default settings\n    initialize_ai_service()\n    \n    app.run(host='0.0.0.0', port=5000, debug=True)","size_bytes":8242},"ai_assistant/ai_assistant/services/erpnext_api.py":{"content":"# Copyright (c) 2025, ERPNext and contributors\n# For license information, please see license.txt\n\nimport json\nimport frappe\nimport requests\nfrom typing import Dict, Any, List, Optional, Union\nfrom frappe import _\nfrom frappe.utils import cint, flt, now_datetime, get_url\nfrom urllib.parse import urljoin\n\n\nclass ERPNextAPIService:\n    \"\"\"\n    ERPNext REST API integration service for AI Assistant.\n    \n    Provides comprehensive document operations through ERPNext's REST API\n    and direct Frappe framework methods when available.\n    \"\"\"\n    \n    def __init__(self, use_rest_api: bool = False, base_url: str = None, api_key: str = None, api_secret: str = None):\n        \"\"\"\n        Initialize ERPNext API service.\n        \n        Args:\n            use_rest_api (bool): Use REST API instead of direct Frappe methods\n            base_url (str): Base URL for REST API calls\n            api_key (str): API key for authentication\n            api_secret (str): API secret for authentication\n        \"\"\"\n        self.use_rest_api = use_rest_api\n        self.base_url = base_url or get_url()\n        self.api_key = api_key\n        self.api_secret = api_secret\n        \n        # Session for REST API calls\n        self.session = requests.Session()\n        if api_key and api_secret:\n            self.session.auth = (api_key, api_secret)\n    \n    def create_document(self, doctype: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Create a new document.\n        \n        Args:\n            doctype (str): DocType name\n            data (Dict[str, Any]): Document data\n            \n        Returns:\n            Dict[str, Any]: Created document data\n        \"\"\"\n        try:\n            if self.use_rest_api:\n                return self._create_document_api(doctype, data)\n            else:\n                return self._create_document_direct(doctype, data)\n                \n        except Exception as e:\n            frappe.log_error(f\"Create document error: {str(e)}\", \"ERPNext API Service\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to create {doctype}: {str(e)}\"\n            }\n    \n    def get_document(self, doctype: str, name: str, fields: List[str] = None) -> Dict[str, Any]:\n        \"\"\"\n        Get a document by name.\n        \n        Args:\n            doctype (str): DocType name\n            name (str): Document name\n            fields (List[str]): Specific fields to fetch\n            \n        Returns:\n            Dict[str, Any]: Document data\n        \"\"\"\n        try:\n            if self.use_rest_api:\n                return self._get_document_api(doctype, name, fields)\n            else:\n                return self._get_document_direct(doctype, name, fields)\n                \n        except Exception as e:\n            frappe.log_error(f\"Get document error: {str(e)}\", \"ERPNext API Service\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to get {doctype} {name}: {str(e)}\"\n            }\n    \n    def update_document(self, doctype: str, name: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Update an existing document.\n        \n        Args:\n            doctype (str): DocType name\n            name (str): Document name\n            data (Dict[str, Any]): Update data\n            \n        Returns:\n            Dict[str, Any]: Updated document data\n        \"\"\"\n        try:\n            if self.use_rest_api:\n                return self._update_document_api(doctype, name, data)\n            else:\n                return self._update_document_direct(doctype, name, data)\n                \n        except Exception as e:\n            frappe.log_error(f\"Update document error: {str(e)}\", \"ERPNext API Service\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to update {doctype} {name}: {str(e)}\"\n            }\n    \n    def delete_document(self, doctype: str, name: str) -> Dict[str, Any]:\n        \"\"\"\n        Delete a document.\n        \n        Args:\n            doctype (str): DocType name\n            name (str): Document name\n            \n        Returns:\n            Dict[str, Any]: Deletion result\n        \"\"\"\n        try:\n            if self.use_rest_api:\n                return self._delete_document_api(doctype, name)\n            else:\n                return self._delete_document_direct(doctype, name)\n                \n        except Exception as e:\n            frappe.log_error(f\"Delete document error: {str(e)}\", \"ERPNext API Service\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to delete {doctype} {name}: {str(e)}\"\n            }\n    \n    def list_documents(self, doctype: str, filters: Dict[str, Any] = None, \n                      fields: List[str] = None, limit: int = 20, \n                      order_by: str = None) -> Dict[str, Any]:\n        \"\"\"\n        List documents with filtering and pagination.\n        \n        Args:\n            doctype (str): DocType name\n            filters (Dict[str, Any]): Filter conditions\n            fields (List[str]): Fields to fetch\n            limit (int): Number of records to fetch\n            order_by (str): Order by clause\n            \n        Returns:\n            Dict[str, Any]: List of documents\n        \"\"\"\n        try:\n            if self.use_rest_api:\n                return self._list_documents_api(doctype, filters, fields, limit, order_by)\n            else:\n                return self._list_documents_direct(doctype, filters, fields, limit, order_by)\n                \n        except Exception as e:\n            frappe.log_error(f\"List documents error: {str(e)}\", \"ERPNext API Service\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to list {doctype}: {str(e)}\"\n            }\n    \n    def search_documents(self, doctype: str, search_term: str, \n                        fields: List[str] = None, limit: int = 10) -> Dict[str, Any]:\n        \"\"\"\n        Search documents by text.\n        \n        Args:\n            doctype (str): DocType name\n            search_term (str): Search term\n            fields (List[str]): Fields to search in\n            limit (int): Number of results\n            \n        Returns:\n            Dict[str, Any]: Search results\n        \"\"\"\n        try:\n            if self.use_rest_api:\n                return self._search_documents_api(doctype, search_term, fields, limit)\n            else:\n                return self._search_documents_direct(doctype, search_term, fields, limit)\n                \n        except Exception as e:\n            frappe.log_error(f\"Search documents error: {str(e)}\", \"ERPNext API Service\")\n            return {\n                \"success\": False,\n                \"error\": f\"Failed to search {doctype}: {str(e)}\"\n            }\n    \n    # Direct Frappe method implementations\n    def _create_document_direct(self, doctype: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Create document using direct Frappe methods.\"\"\"\n        # Check permissions\n        if not frappe.has_permission(doctype, \"create\"):\n            return {\n                \"success\": False,\n                \"error\": f\"No permission to create {doctype}\"\n            }\n        \n        # Create document\n        doc = frappe.get_doc(dict(data, doctype=doctype))\n        doc.insert()\n        \n        return {\n            \"success\": True,\n            \"data\": doc.as_dict(),\n            \"name\": doc.name,\n            \"message\": f\"{doctype} created successfully\"\n        }\n    \n    def _get_document_direct(self, doctype: str, name: str, fields: List[str] = None) -> Dict[str, Any]:\n        \"\"\"Get document using direct Frappe methods.\"\"\"\n        # Check if document exists\n        if not frappe.db.exists(doctype, name):\n            return {\n                \"success\": False,\n                \"error\": f\"{doctype} {name} not found\"\n            }\n        \n        # Check permissions\n        if not frappe.has_permission(doctype, \"read\", doc=name):\n            return {\n                \"success\": False,\n                \"error\": f\"No permission to read {doctype} {name}\"\n            }\n        \n        # Get document\n        if fields:\n            doc_data = frappe.db.get_value(doctype, name, fields, as_dict=True)\n        else:\n            doc = frappe.get_doc(doctype, name)\n            doc_data = doc.as_dict()\n        \n        return {\n            \"success\": True,\n            \"data\": doc_data\n        }\n    \n    def _update_document_direct(self, doctype: str, name: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Update document using direct Frappe methods.\"\"\"\n        # Check if document exists\n        if not frappe.db.exists(doctype, name):\n            return {\n                \"success\": False,\n                \"error\": f\"{doctype} {name} not found\"\n            }\n        \n        # Check permissions\n        if not frappe.has_permission(doctype, \"write\", doc=name):\n            return {\n                \"success\": False,\n                \"error\": f\"No permission to update {doctype} {name}\"\n            }\n        \n        # Update document\n        doc = frappe.get_doc(doctype, name)\n        doc.update(data)\n        doc.save()\n        \n        return {\n            \"success\": True,\n            \"data\": doc.as_dict(),\n            \"message\": f\"{doctype} {name} updated successfully\"\n        }\n    \n    def _delete_document_direct(self, doctype: str, name: str) -> Dict[str, Any]:\n        \"\"\"Delete document using direct Frappe methods.\"\"\"\n        # Check if document exists\n        if not frappe.db.exists(doctype, name):\n            return {\n                \"success\": False,\n                \"error\": f\"{doctype} {name} not found\"\n            }\n        \n        # Check permissions\n        if not frappe.has_permission(doctype, \"delete\", doc=name):\n            return {\n                \"success\": False,\n                \"error\": f\"No permission to delete {doctype} {name}\"\n            }\n        \n        # Delete document\n        frappe.delete_doc(doctype, name)\n        \n        return {\n            \"success\": True,\n            \"message\": f\"{doctype} {name} deleted successfully\"\n        }\n    \n    def _list_documents_direct(self, doctype: str, filters: Dict[str, Any] = None, \n                              fields: List[str] = None, limit: int = 20, \n                              order_by: str = None) -> Dict[str, Any]:\n        \"\"\"List documents using direct Frappe methods.\"\"\"\n        # Check permissions\n        if not frappe.has_permission(doctype, \"read\"):\n            return {\n                \"success\": False,\n                \"error\": f\"No permission to read {doctype}\"\n            }\n        \n        # Build query parameters\n        query_params = {\n            \"doctype\": doctype,\n            \"limit_page_length\": limit\n        }\n        \n        if filters:\n            query_params[\"filters\"] = filters\n        if fields:\n            query_params[\"fields\"] = fields\n        if order_by:\n            query_params[\"order_by\"] = order_by\n        \n        # Get documents\n        documents = frappe.get_all(**query_params)\n        \n        return {\n            \"success\": True,\n            \"data\": documents,\n            \"count\": len(documents)\n        }\n    \n    def _search_documents_direct(self, doctype: str, search_term: str, \n                                fields: List[str] = None, limit: int = 10) -> Dict[str, Any]:\n        \"\"\"Search documents using direct Frappe methods.\"\"\"\n        # Check permissions\n        if not frappe.has_permission(doctype, \"read\"):\n            return {\n                \"success\": False,\n                \"error\": f\"No permission to read {doctype}\"\n            }\n        \n        # Perform search\n        results = frappe.db.sql(\"\"\"\n            SELECT name, title, {fields}\n            FROM `tab{doctype}`\n            WHERE title LIKE %s OR name LIKE %s\n            ORDER BY modified DESC\n            LIMIT %s\n        \"\"\".format(\n            fields=\", \".join(fields) if fields else \"*\",\n            doctype=doctype\n        ), (f\"%{search_term}%\", f\"%{search_term}%\", limit), as_dict=True)\n        \n        return {\n            \"success\": True,\n            \"data\": results,\n            \"count\": len(results)\n        }\n    \n    # REST API method implementations (for external ERPNext instances)\n    def _create_document_api(self, doctype: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Create document using REST API.\"\"\"\n        url = urljoin(self.base_url, f\"/api/resource/{doctype}\")\n        response = self.session.post(url, json=data)\n        \n        if response.status_code == 200:\n            return {\n                \"success\": True,\n                \"data\": response.json().get(\"data\"),\n                \"message\": f\"{doctype} created successfully\"\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": f\"API Error: {response.status_code} - {response.text}\"\n            }\n    \n    def _get_document_api(self, doctype: str, name: str, fields: List[str] = None) -> Dict[str, Any]:\n        \"\"\"Get document using REST API.\"\"\"\n        url = urljoin(self.base_url, f\"/api/resource/{doctype}/{name}\")\n        params = {}\n        if fields:\n            params[\"fields\"] = json.dumps(fields)\n        \n        response = self.session.get(url, params=params)\n        \n        if response.status_code == 200:\n            return {\n                \"success\": True,\n                \"data\": response.json().get(\"data\")\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": f\"API Error: {response.status_code} - {response.text}\"\n            }\n    \n    def _update_document_api(self, doctype: str, name: str, data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Update document using REST API.\"\"\"\n        url = urljoin(self.base_url, f\"/api/resource/{doctype}/{name}\")\n        response = self.session.put(url, json=data)\n        \n        if response.status_code == 200:\n            return {\n                \"success\": True,\n                \"data\": response.json().get(\"data\"),\n                \"message\": f\"{doctype} {name} updated successfully\"\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": f\"API Error: {response.status_code} - {response.text}\"\n            }\n    \n    def _delete_document_api(self, doctype: str, name: str) -> Dict[str, Any]:\n        \"\"\"Delete document using REST API.\"\"\"\n        url = urljoin(self.base_url, f\"/api/resource/{doctype}/{name}\")\n        response = self.session.delete(url)\n        \n        if response.status_code == 202:\n            return {\n                \"success\": True,\n                \"message\": f\"{doctype} {name} deleted successfully\"\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": f\"API Error: {response.status_code} - {response.text}\"\n            }\n    \n    def _list_documents_api(self, doctype: str, filters: Dict[str, Any] = None, \n                           fields: List[str] = None, limit: int = 20, \n                           order_by: str = None) -> Dict[str, Any]:\n        \"\"\"List documents using REST API.\"\"\"\n        url = urljoin(self.base_url, f\"/api/resource/{doctype}\")\n        params = {\"limit_page_length\": limit}\n        \n        if filters:\n            params[\"filters\"] = json.dumps(filters)\n        if fields:\n            params[\"fields\"] = json.dumps(fields)\n        if order_by:\n            params[\"order_by\"] = order_by\n        \n        response = self.session.get(url, params=params)\n        \n        if response.status_code == 200:\n            return {\n                \"success\": True,\n                \"data\": response.json().get(\"data\"),\n                \"count\": len(response.json().get(\"data\", []))\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": f\"API Error: {response.status_code} - {response.text}\"\n            }\n    \n    def _search_documents_api(self, doctype: str, search_term: str, \n                             fields: List[str] = None, limit: int = 10) -> Dict[str, Any]:\n        \"\"\"Search documents using REST API.\"\"\"\n        url = urljoin(self.base_url, f\"/api/resource/{doctype}\")\n        params = {\n            \"limit_page_length\": limit,\n            \"filters\": json.dumps([[\"name\", \"like\", f\"%{search_term}%\"]])\n        }\n        \n        if fields:\n            params[\"fields\"] = json.dumps(fields)\n        \n        response = self.session.get(url, params=params)\n        \n        if response.status_code == 200:\n            return {\n                \"success\": True,\n                \"data\": response.json().get(\"data\"),\n                \"count\": len(response.json().get(\"data\", []))\n            }\n        else:\n            return {\n                \"success\": False,\n                \"error\": f\"API Error: {response.status_code} - {response.text}\"\n            }\n\n\ndef get_erpnext_api_service() -> ERPNextAPIService:\n    \"\"\"\n    Get ERPNext API service instance.\n    \n    Returns:\n        ERPNextAPIService: Service instance\n    \"\"\"\n    return ERPNextAPIService()","size_bytes":17140}},"version":1}